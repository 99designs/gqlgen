// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"

	"github.com/99designs/gqlgen/plugin/federation/fedruntime"
	"github.com/99designs/gqlgen/plugin/federation/testdata/allthethings/model"
)

func (ec *executionContext) __resolve__service(ctx context.Context) (fedruntime.Service, error) {
	if ec.DisableIntrospection {
		return fedruntime.Service{}, errors.New("federated introspection disabled")
	}

	var sdl []string

	for _, src := range sources {
		if src.BuiltIn {
			continue
		}
		sdl = append(sdl, src.Input)
	}

	return fedruntime.Service{
		SDL: strings.Join(sdl, "\n"),
	}, nil
}

func (ec *executionContext) __resolve_entities(ctx context.Context, representations []map[string]interface{}) []fedruntime.Entity {
	list := make([]fedruntime.Entity, len(representations))
	resolveEntity := func(ctx context.Context, i int, rep map[string]interface{}) (err error) {
		// we need to do our own panic handling, because we may be called in a
		// goroutine, where the usual panic handling can't catch us
		defer func() {
			if r := recover(); r != nil {
				err = ec.Recover(ctx, r)
			}
		}()

		typeName, ok := rep["__typename"].(string)
		if !ok {
			return errors.New("__typename must be an existing string")
		}
		switch typeName {
		case "ExternalExtension":
			entity, err := func() (*model.ExternalExtension, error) {
				id0, err := ec.unmarshalNString2string(ctx, rep["upc"])
				if err == nil {
					return ec.resolvers.Entity().FindExternalExtensionByUpc(ctx, id0)
				}
				return nil, nil
			}()

			if err != nil {
				return fmt.Errorf(`resolving Entity "ExternalExtension": %w`, err)
			}
			if entity == nil {
				return errors.New(`unable to resolve Entity "ExternalExtension"`)
			}

			list[i] = entity
			return nil

		case "Hello":
			entity, err := func() (*model.Hello, error) {
				id0, err := ec.unmarshalNString2string(ctx, rep["name"])
				if err == nil {
					return ec.resolvers.Entity().FindHelloByName(ctx, id0)
				}
				return nil, nil
			}()

			if err != nil {
				return fmt.Errorf(`resolving Entity "Hello": %w`, err)
			}
			if entity == nil {
				return errors.New(`unable to resolve Entity "Hello"`)
			}

			list[i] = entity
			return nil

		case "NestedKey":
			entity, err := func() (*model.NestedKey, error) {
				id0, err := ec.unmarshalNString2string(ctx, rep["id"])
				if err == nil {
					id1, err := ec.unmarshalNString2string(ctx, rep["hello"].(map[string]interface{})["name"])
					if err == nil {
						return ec.resolvers.Entity().FindNestedKeyByIDAndHelloName(ctx, id0, id1)
					}
				}
				return nil, nil
			}()

			if err != nil {
				return fmt.Errorf(`resolving Entity "NestedKey": %w`, err)
			}
			if entity == nil {
				return errors.New(`unable to resolve Entity "NestedKey"`)
			}

			list[i] = entity
			return nil

		case "VeryNestedKey":
			entity, err := func() (*model.VeryNestedKey, error) {
				id0, err := ec.unmarshalNString2string(ctx, rep["id"])
				if err == nil {
					id1, err := ec.unmarshalNString2string(ctx, rep["hello"].(map[string]interface{})["name"])
					if err == nil {
						id2, err := ec.unmarshalNString2string(ctx, rep["world"].(map[string]interface{})["foo"])
						if err == nil {
							id3, err := ec.unmarshalNInt2int(ctx, rep["world"].(map[string]interface{})["bar"])
							if err == nil {
								id4, err := ec.unmarshalNString2string(ctx, rep["more"].(map[string]interface{})["world"].(map[string]interface{})["foo"])
								if err == nil {
									return ec.resolvers.Entity().FindVeryNestedKeyByIDAndHelloNameAndWorldFooAndWorldBarAndMoreWorldFoo(ctx, id0, id1, id2, id3, id4)
								}
							}
						}
					}
				}
				return nil, nil
			}()

			if err != nil {
				return fmt.Errorf(`resolving Entity "VeryNestedKey": %w`, err)
			}
			if entity == nil {
				return errors.New(`unable to resolve Entity "VeryNestedKey"`)
			}

			entity.ID, err = ec.unmarshalNString2string(ctx, rep["id"])
			if err != nil {
				return err
			}

			entity.Hello.Secondary, err = ec.unmarshalNString2string(ctx, rep["helloSecondary"])
			if err != nil {
				return err
			}

			list[i] = entity
			return nil

		case "World":
			entity, err := func() (*model.World, error) {
				id0, err := ec.unmarshalNString2string(ctx, rep["foo"])
				if err == nil {
					return ec.resolvers.Entity().FindWorldByFoo(ctx, id0)
				}
				return nil, nil
			}()

			if entity == nil {
				entity, err = func() (*model.World, error) {
					id0, err := ec.unmarshalNInt2int(ctx, rep["bar"])
					if err == nil {
						return ec.resolvers.Entity().FindWorldByBar(ctx, id0)
					}
					return nil, nil
				}()
			}

			if err != nil {
				return fmt.Errorf(`resolving Entity "World": %w`, err)
			}
			if entity == nil {
				return errors.New(`unable to resolve Entity "World"`)
			}

			list[i] = entity
			return nil

		default:
			return errors.New("unknown type: " + typeName)
		}
	}

	// if there are multiple entities to resolve, parallelize (similar to
	// graphql.FieldSet.Dispatch)
	switch len(representations) {
	case 0:
		return list
	case 1:
		err := resolveEntity(ctx, 0, representations[0])
		if err != nil {
			ec.Error(ctx, err)
		}
		return list
	default:
		var g sync.WaitGroup
		g.Add(len(representations))
		for i, rep := range representations {
			go func(i int, rep map[string]interface{}) {
				err := resolveEntity(ctx, i, rep)
				if err != nil {
					ec.Error(ctx, err)
				}
				g.Done()
			}(i, rep)
		}
		g.Wait()
		return list
	}
}
