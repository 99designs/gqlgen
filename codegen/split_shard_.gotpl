{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "sync/atomic" }}

{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/executor/shardruntime" }}

const splitScope = {{ .Scope | quote }}

func init() {
{{- range $object := .Objects }}
	{{- if $object.Stream }}
	shardruntime.RegisterStreamObject(splitScope, {{ $object.Name | quote }}, func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet) func(context.Context) graphql.Marshaler {
		return _{{ $object.Name }}(ctx, ec, sel)
	})
	{{- else }}
	shardruntime.RegisterObject(splitScope, {{ $object.Name | quote }}, func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		{{- if $object.Root }}
		return _{{ $object.Name }}(ctx, ec, sel)
		{{- else }}
		typedObj, ok := obj.({{ $object.Reference | ref }})
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object {{ $object.Name }}", obj))
		}
		return _{{ $object.Name }}(ctx, ec, sel, typedObj)
		{{- end }}
	})
	{{- end }}
{{- end }}
}

{{- range $object := .Objects }}

var {{ $object.Name|lcFirst}}Implementors = {{$object.Implementors}}

{{- if .Stream }}
func _{{$object.Name}}(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, {{$object.Name|lcFirst}}Implementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: {{$object.Name|quote}},
	})
	if len(fields) != 1 {
		graphql.AddErrorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	{{- range $field := $object.Fields }}
	case "{{$field.Name}}":
		return ec.ResolveStreamField(ctx, {{$object.Name|quote}}, {{$field.Name|quote}}, fields[0], nil)
	{{- end }}
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}
{{- else }}

func _{{$object.Name}}(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet{{ if not $object.Root }},obj {{$object.Reference | ref }}{{ end }}) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, {{$object.Name|lcFirst}}Implementors)
	{{- if $object.Root }}
		ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
			Object: {{$object.Name|quote}},
		})
	{{end}}

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		{{- if $object.Root }}
			innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
				Object: field.Name,
				Field: field,
			})
		{{end}}
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString({{$object.Name|quote}})
		{{- range $field := $object.Fields }}
		case "{{$field.Name}}":
			{{- if $field.IsConcurrent }}
				field := field

				innerFunc := func(ctx context.Context, {{ if $field.TypeReference.GQL.NonNull }}fs{{ else }}_{{ end }} *graphql.FieldSet) (res graphql.Marshaler) {
					{{- if not $.Config.OmitPanicHandler }}
					defer func() {
						if r := recover(); r != nil {
							ec.Error(ctx, ec.Recover(ctx, r))
						}
					}()
					{{- end }}
					res = ec.ResolveField(ctx, {{$object.Name|quote}}, {{$field.Name|quote}}, field, {{if $object.Root}}nil{{else}}obj{{end}})
					{{- if $field.TypeReference.GQL.NonNull }}
						if res == graphql.Null {
							{{- if $object.IsConcurrent }}
								atomic.AddUint32(&fs.Invalids, 1)
							{{- else }}
								fs.Invalids++
							{{- end }}
						}
					{{- end }}
					return res
				}

				{{if $object.Root}}
					rrm := func(ctx context.Context) graphql.Marshaler {
						return ec.GetOperationContext().RootResolverMiddleware(ctx,
							func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
					}
				{{end}}

				{{if not $object.Root}}
					if field.Deferrable != nil {
						dfs, ok := deferred[field.Deferrable.Label]
						di := 0
						if ok {
							dfs.AddField(field)
							di = len(dfs.Values) - 1
						} else {
							dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
							deferred[field.Deferrable.Label] = dfs
						}
						dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
							return innerFunc(ctx, dfs)
						})

						// don't run the out.Concurrently() call below
						out.Values[i] = graphql.Null
						continue
					}
				{{end}}

				out.Concurrently(i, func(ctx context.Context) graphql.Marshaler {
					{{- if $object.Root -}}
						return rrm(innerCtx)
					{{- else -}}
						return innerFunc(ctx, out)
					{{- end -}}
				})
			{{- else }}
				{{- if $object.Root -}}
					out.Values[i] = ec.GetOperationContext().RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
						return ec.ResolveField(ctx, {{$object.Name|quote}}, {{$field.Name|quote}}, field, nil)
					})
				{{- else -}}
					out.Values[i] = ec.ResolveField(ctx, {{$object.Name|quote}}, {{$field.Name|quote}}, field, obj)
				{{- end -}}

				{{- if $field.TypeReference.GQL.NonNull }}
					if out.Values[i] == graphql.Null {
						{{- if $object.IsConcurrent }}
							atomic.AddUint32(&out.Invalids, 1)
						{{- else }}
							out.Invalids++
						{{- end }}
					}
				{{- end }}
			{{- end }}
		{{- end }}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 { return graphql.Null }

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}
{{- end }}

{{- end }}

{{ template "split_fields_.gotpl" . }}
{{ template "split_args_.gotpl" . }}
{{ template "split_directives_.gotpl" . }}
{{ template "split_complexity_.gotpl" . }}
{{ template "split_inputs_.gotpl" . }}
{{ template "split_codecs_.gotpl" . }}
