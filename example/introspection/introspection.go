// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package introspection

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** directive.gotpl ***************************

type IntrospectionConfig struct {
	HideFunc        func(ctx context.Context, directive *ast.Directive) (allow bool, err error)
	RequireAuthFunc func(ctx context.Context, directive *ast.Directive) (allow bool, err error)
}

func IntrospectionDirective(cfg IntrospectionConfig) func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {
	return func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error) {
		res, err = next(ctx)
		if nil != err {
			return
		}
		introspectedType := obj.(*introspection.Type)
		schemaType := parsedSchema.Types[*introspectedType.Name()]
		switch fields := res.(type) {

		case []introspection.Field:
			newFields := make([]introspection.Field, 0, len(fields))

			for _, f := range fields {
				schemaField := schemaType.Fields.ForName(f.Name)
				if hideDirective := schemaField.Directives.ForName("hide"); hideDirective != nil {
					allow, err := cfg.HideFunc(ctx, hideDirective)
					if nil != err {
						return nil, err
					}
					if !allow {
						continue
					}
				}
				if requireAuthDirective := schemaField.Directives.ForName("requireAuth"); requireAuthDirective != nil {
					allow, err := cfg.RequireAuthFunc(ctx, requireAuthDirective)
					if nil != err {
						return nil, err
					}
					if !allow {
						continue
					}
				}
				newFields = append(newFields, f)
			}
			res = newFields

		case []introspection.InputValue:
			newFields := make([]introspection.InputValue, 0, len(fields))

			for _, f := range fields {
				schemaField := schemaType.Fields.ForName(f.Name)
				if hideDirective := schemaField.Directives.ForName("hide"); hideDirective != nil {
					allow, err := cfg.HideFunc(ctx, hideDirective)
					if nil != err {
						return nil, err
					}
					if !allow {
						continue
					}
				}
				if requireAuthDirective := schemaField.Directives.ForName("requireAuth"); requireAuthDirective != nil {
					allow, err := cfg.RequireAuthFunc(ctx, requireAuthDirective)
					if nil != err {
						return nil, err
					}
					if !allow {
						continue
					}
				}
				newFields = append(newFields, f)
			}
			res = newFields

		}
		return
	}
}

// endregion ************************** directive.gotpl ***************************
