// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package followschema

import (
	"bytes"
	"context"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{SchemaData: cfg.Schema, Resolvers: cfg.Resolvers, Directives: cfg.Directives, ComplexityRoot: cfg.Complexity}
}

type Config = graphql.Config[ResolverRoot, DirectiveRoot, ComplexityRoot]

type ResolverRoot interface {
	BackedByInterface() BackedByInterfaceResolver
	DeferModel() DeferModelResolver
	Errors() ErrorsResolver
	ForcedResolver() ForcedResolverResolver
	ModelMethods() ModelMethodsResolver
	Mutation() MutationResolver
	OverlappingFields() OverlappingFieldsResolver
	Panics() PanicsResolver
	Pet() PetResolver
	Primitive() PrimitiveResolver
	PrimitiveString() PrimitiveStringResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
	WrappedMap() WrappedMapResolver
	WrappedSlice() WrappedSliceResolver
	FieldsOrderInput() FieldsOrderInputResolver
}

type DirectiveRoot struct {
	Custom        func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Defer         func(ctx context.Context, obj any, next graphql.Resolver, ifArg *bool, label *string) (res any, err error)
	Directive1    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Directive2    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Directive3    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Length        func(ctx context.Context, obj any, next graphql.Resolver, min int, max *int, message *string) (res any, err error)
	Logged        func(ctx context.Context, obj any, next graphql.Resolver, id string) (res any, err error)
	MakeNil       func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	MakeTypedNil  func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Noop          func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Order1        func(ctx context.Context, obj any, next graphql.Resolver, location string) (res any, err error)
	Order2        func(ctx context.Context, obj any, next graphql.Resolver, location string) (res any, err error)
	Populate      func(ctx context.Context, obj any, next graphql.Resolver, value string) (res any, err error)
	Range         func(ctx context.Context, obj any, next graphql.Resolver, min *int, max *int) (res any, err error)
	ToNull        func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	Unimplemented func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	A struct {
		ID func(childComplexity int) int
	}

	AIt struct {
		ID func(childComplexity int) int
	}

	AbIt struct {
		ID func(childComplexity int) int
	}

	Autobind struct {
		IdInt func(childComplexity int) int
		IdStr func(childComplexity int) int
		Int   func(childComplexity int) int
		Int32 func(childComplexity int) int
		Int64 func(childComplexity int) int
	}

	B struct {
		ID func(childComplexity int) int
	}

	BackedByInterface struct {
		ID                      func(childComplexity int) int
		ThisShouldBind          func(childComplexity int) int
		ThisShouldBindWithError func(childComplexity int) int
	}

	Cat struct {
		CatBreed func(childComplexity int) int
		Size     func(childComplexity int) int
		Species  func(childComplexity int) int
	}

	CheckIssue896 struct {
		ID func(childComplexity int) int
	}

	Circle struct {
		Area        func(childComplexity int) int
		Coordinates func(childComplexity int) int
		Radius      func(childComplexity int) int
	}

	ConcreteNodeA struct {
		Child func(childComplexity int) int
		ID    func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	ConcreteNodeInterface struct {
		Child func(childComplexity int) int
		ID    func(childComplexity int) int
	}

	Content_Post struct {
		Foo func(childComplexity int) int
	}

	Content_User struct {
		Foo func(childComplexity int) int
	}

	Coordinates struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	DefaultParametersMirror struct {
		FalsyBoolean  func(childComplexity int) int
		TruthyBoolean func(childComplexity int) int
	}

	DeferModel struct {
		ID     func(childComplexity int) int
		Name   func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Dog struct {
		DogBreed func(childComplexity int) int
		Size     func(childComplexity int) int
		Species  func(childComplexity int) int
	}

	EmbeddedCase1 struct {
		ExportedEmbeddedPointerExportedMethod func(childComplexity int) int
	}

	EmbeddedCase2 struct {
		UnexportedEmbeddedPointerExportedMethod func(childComplexity int) int
	}

	EmbeddedCase3 struct {
		UnexportedEmbeddedInterfaceExportedMethod func(childComplexity int) int
	}

	EmbeddedDefaultScalar struct {
		Value func(childComplexity int) int
	}

	EmbeddedPointer struct {
		ID    func(childComplexity int) int
		Title func(childComplexity int) int
	}

	Error struct {
		ErrorOnNonRequiredField func(childComplexity int) int
		ErrorOnRequiredField    func(childComplexity int) int
		ID                      func(childComplexity int) int
		NilOnRequiredField      func(childComplexity int) int
	}

	Errors struct {
		A func(childComplexity int) int
		B func(childComplexity int) int
		C func(childComplexity int) int
		D func(childComplexity int) int
		E func(childComplexity int) int
	}

	FieldsOrderPayload struct {
		FirstFieldValue func(childComplexity int) int
	}

	ForcedResolver struct {
		Field func(childComplexity int) int
	}

	Horse struct {
		HorseBreed func(childComplexity int) int
		Size       func(childComplexity int) int
		Species    func(childComplexity int) int
	}

	InnerObject struct {
		ID func(childComplexity int) int
	}

	InvalidIdentifier struct {
		ID func(childComplexity int) int
	}

	It struct {
		ID func(childComplexity int) int
	}

	LoopA struct {
		B func(childComplexity int) int
	}

	LoopB struct {
		A func(childComplexity int) int
	}

	Map struct {
		ID func(childComplexity int) int
	}

	MapNested struct {
		Value func(childComplexity int) int
	}

	MapStringInterfaceType struct {
		A      func(childComplexity int) int
		B      func(childComplexity int) int
		C      func(childComplexity int) int
		Nested func(childComplexity int) int
	}

	ModelMethods struct {
		NoContext     func(childComplexity int) int
		ResolverField func(childComplexity int) int
		WithContext   func(childComplexity int) int
	}

	Mutation struct {
		DefaultInput          func(childComplexity int, input DefaultInput) int
		OverrideValueViaInput func(childComplexity int, input FieldsOrderInput) int
		UpdateProduct         func(childComplexity int, id string, name *string, price *float64) int
		UpdatePtrToPtr        func(childComplexity int, input UpdatePtrToPtrOuter) int
		UpdateSomething       func(childComplexity int, input SpecialInput) int
	}

	ObjectDirectives struct {
		NullableText func(childComplexity int) int
		Order        func(childComplexity int) int
		Text         func(childComplexity int) int
	}

	ObjectDirectivesWithCustomGoModel struct {
		NullableText func(childComplexity int) int
	}

	OuterObject struct {
		Inner func(childComplexity int) int
	}

	OverlappingFields struct {
		Foo    func(childComplexity int) int
		NewFoo func(childComplexity int) int
		OldFoo func(childComplexity int) int
	}

	Panics struct {
		ArgUnmarshal       func(childComplexity int, u []MarshalPanic) int
		FieldFuncMarshal   func(childComplexity int, u []MarshalPanic) int
		FieldScalarMarshal func(childComplexity int) int
	}

	Pet struct {
		Friends func(childComplexity int, limit *int) int
		ID      func(childComplexity int) int
	}

	Primitive struct {
		Squared func(childComplexity int) int
		Value   func(childComplexity int) int
	}

	PrimitiveString struct {
		Doubled func(childComplexity int) int
		Len     func(childComplexity int) int
		Value   func(childComplexity int) int
	}

	PtrToAnyContainer struct {
		Binding  func(childComplexity int) int
		PtrToAny func(childComplexity int) int
	}

	PtrToPtrInner struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	PtrToPtrOuter struct {
		Inner       func(childComplexity int) int
		Name        func(childComplexity int) int
		StupidInner func(childComplexity int) int
	}

	PtrToSliceContainer struct {
		PtrToSlice func(childComplexity int) int
	}

	Query struct {
		Animal                           func(childComplexity int) int
		Autobind                         func(childComplexity int) int
		Collision                        func(childComplexity int) int
		DefaultParameters                func(childComplexity int, falsyBoolean *bool, truthyBoolean *bool) int
		DefaultScalar                    func(childComplexity int, arg string) int
		DeferMultiple                    func(childComplexity int) int
		DeferSingle                      func(childComplexity int) int
		DeprecatedField                  func(childComplexity int) int
		DirectiveArg                     func(childComplexity int, arg string) int
		DirectiveDouble                  func(childComplexity int) int
		DirectiveField                   func(childComplexity int) int
		DirectiveFieldDef                func(childComplexity int, ret string) int
		DirectiveInput                   func(childComplexity int, arg InputDirectives) int
		DirectiveInputNullable           func(childComplexity int, arg *InputDirectives) int
		DirectiveInputType               func(childComplexity int, arg InnerInput) int
		DirectiveNullableArg             func(childComplexity int, arg *int, arg2 *int, arg3 *string) int
		DirectiveObject                  func(childComplexity int) int
		DirectiveObjectWithCustomGoModel func(childComplexity int) int
		DirectiveSingleNullableArg       func(childComplexity int, arg1 *string) int
		DirectiveUnimplemented           func(childComplexity int) int
		Dog                              func(childComplexity int) int
		EmbeddedCase1                    func(childComplexity int) int
		EmbeddedCase2                    func(childComplexity int) int
		EmbeddedCase3                    func(childComplexity int) int
		EnumInInput                      func(childComplexity int, input *InputWithEnumValue) int
		ErrorBubble                      func(childComplexity int) int
		ErrorBubbleList                  func(childComplexity int) int
		ErrorList                        func(childComplexity int) int
		Errors                           func(childComplexity int) int
		Fallback                         func(childComplexity int, arg FallbackToStringEncoding) int
		FieldWithDeprecatedArg           func(childComplexity int, oldArg *int, newArg *int) int
		FilterProducts                   func(childComplexity int, query *string, category *string, minPrice *int) int
		FindProducts                     func(childComplexity int, query *string, category *string, minPrice *int) int
		Infinity                         func(childComplexity int) int
		InputNullableSlice               func(childComplexity int, arg []string) int
		InputOmittable                   func(childComplexity int, arg OmittableInput) int
		InputSlice                       func(childComplexity int, arg []string) int
		Invalid                          func(childComplexity int) int
		InvalidIdentifier                func(childComplexity int) int
		Issue896a                        func(childComplexity int) int
		MapInput                         func(childComplexity int, input map[string]any) int
		MapNestedMapSlice                func(childComplexity int, input map[string]any) int
		MapNestedStringInterface         func(childComplexity int, in *NestedMapInput) int
		MapStringInterface               func(childComplexity int, in map[string]any) int
		ModelMethods                     func(childComplexity int) int
		NestedInputs                     func(childComplexity int, input [][]*OuterInput) int
		NestedOutputs                    func(childComplexity int) int
		NoShape                          func(childComplexity int) int
		NoShapeTypedNil                  func(childComplexity int) int
		Node                             func(childComplexity int) int
		NotAnInterface                   func(childComplexity int) int
		NullableArg                      func(childComplexity int, arg *int) int
		OptionalUnion                    func(childComplexity int) int
		Overlapping                      func(childComplexity int) int
		Panics                           func(childComplexity int) int
		PrimitiveObject                  func(childComplexity int) int
		PrimitiveStringObject            func(childComplexity int) int
		PtrToAnyContainer                func(childComplexity int) int
		PtrToSliceContainer              func(childComplexity int) int
		Recursive                        func(childComplexity int, input *RecursiveInputSlice) int
		ScalarSlice                      func(childComplexity int) int
		SearchMixed                      func(childComplexity int, query *string, category *string, minPrice *int, limit *int, offset *int, sortBy *string) int
		SearchProducts                   func(childComplexity int, query *string, category *string, minPrice *int) int
		SearchProductsNormal             func(childComplexity int, filters map[string]any) int
		SearchRequired                   func(childComplexity int, name string, age int) int
		SearchWithDefaults               func(childComplexity int, query *string, limit *int, includeArchived *bool) int
		SearchWithDirectives             func(childComplexity int, oldField *string, newField *string) int
		ShapeUnion                       func(childComplexity int) int
		Shapes                           func(childComplexity int) int
		SkipInclude                      func(childComplexity int) int
		Slices                           func(childComplexity int) int
		StringFromContextFunction        func(childComplexity int) int
		StringFromContextInterface       func(childComplexity int) int
		User                             func(childComplexity int, id int) int
		VOkCaseNil                       func(childComplexity int) int
		VOkCaseValue                     func(childComplexity int) int
		Valid                            func(childComplexity int) int
		ValidType                        func(childComplexity int) int
		VariadicModel                    func(childComplexity int) int
		WrappedMap                       func(childComplexity int) int
		WrappedScalar                    func(childComplexity int) int
		WrappedSlice                     func(childComplexity int) int
		WrappedStruct                    func(childComplexity int) int
	}

	Rectangle struct {
		Area        func(childComplexity int) int
		Coordinates func(childComplexity int) int
		Length      func(childComplexity int) int
		Width       func(childComplexity int) int
	}

	Size struct {
		Height func(childComplexity int) int
		Weight func(childComplexity int) int
	}

	SkipIncludeTestType struct {
		A func(childComplexity int) int
		B func(childComplexity int) int
	}

	Slices struct {
		Test1 func(childComplexity int) int
		Test2 func(childComplexity int) int
		Test3 func(childComplexity int) int
		Test4 func(childComplexity int) int
	}

	Subscription struct {
		DirectiveArg           func(childComplexity int, arg string) int
		DirectiveDouble        func(childComplexity int) int
		DirectiveNullableArg   func(childComplexity int, arg *int, arg2 *int, arg3 *string) int
		DirectiveUnimplemented func(childComplexity int) int
		ErrorRequired          func(childComplexity int) int
		InitPayload            func(childComplexity int) int
		Issue896b              func(childComplexity int) int
		Updated                func(childComplexity int) int
	}

	User struct {
		Created func(childComplexity int) int
		Friends func(childComplexity int) int
		ID      func(childComplexity int) int
		Pets    func(childComplexity int, limit *int) int
		Updated func(childComplexity int) int
	}

	VOkCaseNil struct {
		Value func(childComplexity int) int
	}

	VOkCaseValue struct {
		Value func(childComplexity int) int
	}

	ValidType struct {
		DifferentCase      func(childComplexity int) int
		DifferentCaseOld   func(childComplexity int) int
		ValidArgs          func(childComplexity int, breakArg string, defaultArg string, funcArg string, interfaceArg string, selectArg string, caseArg string, deferArg string, goArg string, mapArg string, structArg string, chanArg string, elseArg string, gotoArg string, packageArg string, switchArg string, constArg string, fallthroughArg string, ifArg string, rangeArg string, typeArg string, continueArg string, forArg string, importArg string, returnArg string, varArg string, _ string) int
		ValidInputKeywords func(childComplexity int, input *ValidInput) int
	}

	VariadicModel struct {
		Value func(childComplexity int, rank int) int
	}

	WrappedMap struct {
		Get func(childComplexity int, key string) int
	}

	WrappedSlice struct {
		Get func(childComplexity int, idx int) int
	}

	WrappedStruct struct {
		Desc func(childComplexity int) int
		Name func(childComplexity int) int
	}

	XXIt struct {
		ID func(childComplexity int) int
	}

	XxIt struct {
		ID func(childComplexity int) int
	}

	AsdfIt struct {
		ID func(childComplexity int) int
	}

	IIt struct {
		ID func(childComplexity int) int
	}
}

type executableSchema graphql.ExecutableSchemaState[ResolverRoot, DirectiveRoot, ComplexityRoot]

func (e *executableSchema) Schema() *ast.Schema {
	if e.SchemaData != nil {
		return e.SchemaData
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := newExecutionContext(nil, e, nil)
	_ = ec
	switch typeName + "." + field {

	case "A.id":
		if e.ComplexityRoot.A.ID == nil {
			break
		}

		return e.ComplexityRoot.A.ID(childComplexity), true

	case "AIt.id":
		if e.ComplexityRoot.AIt.ID == nil {
			break
		}

		return e.ComplexityRoot.AIt.ID(childComplexity), true

	case "AbIt.id":
		if e.ComplexityRoot.AbIt.ID == nil {
			break
		}

		return e.ComplexityRoot.AbIt.ID(childComplexity), true

	case "Autobind.idInt":
		if e.ComplexityRoot.Autobind.IdInt == nil {
			break
		}

		return e.ComplexityRoot.Autobind.IdInt(childComplexity), true

	case "Autobind.idStr":
		if e.ComplexityRoot.Autobind.IdStr == nil {
			break
		}

		return e.ComplexityRoot.Autobind.IdStr(childComplexity), true

	case "Autobind.int":
		if e.ComplexityRoot.Autobind.Int == nil {
			break
		}

		return e.ComplexityRoot.Autobind.Int(childComplexity), true

	case "Autobind.int32":
		if e.ComplexityRoot.Autobind.Int32 == nil {
			break
		}

		return e.ComplexityRoot.Autobind.Int32(childComplexity), true

	case "Autobind.int64":
		if e.ComplexityRoot.Autobind.Int64 == nil {
			break
		}

		return e.ComplexityRoot.Autobind.Int64(childComplexity), true

	case "B.id":
		if e.ComplexityRoot.B.ID == nil {
			break
		}

		return e.ComplexityRoot.B.ID(childComplexity), true

	case "BackedByInterface.id":
		if e.ComplexityRoot.BackedByInterface.ID == nil {
			break
		}

		return e.ComplexityRoot.BackedByInterface.ID(childComplexity), true

	case "BackedByInterface.thisShouldBind":
		if e.ComplexityRoot.BackedByInterface.ThisShouldBind == nil {
			break
		}

		return e.ComplexityRoot.BackedByInterface.ThisShouldBind(childComplexity), true

	case "BackedByInterface.thisShouldBindWithError":
		if e.ComplexityRoot.BackedByInterface.ThisShouldBindWithError == nil {
			break
		}

		return e.ComplexityRoot.BackedByInterface.ThisShouldBindWithError(childComplexity), true

	case "Cat.catBreed":
		if e.ComplexityRoot.Cat.CatBreed == nil {
			break
		}

		return e.ComplexityRoot.Cat.CatBreed(childComplexity), true

	case "Cat.size":
		if e.ComplexityRoot.Cat.Size == nil {
			break
		}

		return e.ComplexityRoot.Cat.Size(childComplexity), true

	case "Cat.species":
		if e.ComplexityRoot.Cat.Species == nil {
			break
		}

		return e.ComplexityRoot.Cat.Species(childComplexity), true

	case "CheckIssue896.id":
		if e.ComplexityRoot.CheckIssue896.ID == nil {
			break
		}

		return e.ComplexityRoot.CheckIssue896.ID(childComplexity), true

	case "Circle.area":
		if e.ComplexityRoot.Circle.Area == nil {
			break
		}

		return e.ComplexityRoot.Circle.Area(childComplexity), true

	case "Circle.coordinates":
		if e.ComplexityRoot.Circle.Coordinates == nil {
			break
		}

		return e.ComplexityRoot.Circle.Coordinates(childComplexity), true

	case "Circle.radius":
		if e.ComplexityRoot.Circle.Radius == nil {
			break
		}

		return e.ComplexityRoot.Circle.Radius(childComplexity), true

	case "ConcreteNodeA.child":
		if e.ComplexityRoot.ConcreteNodeA.Child == nil {
			break
		}

		return e.ComplexityRoot.ConcreteNodeA.Child(childComplexity), true

	case "ConcreteNodeA.id":
		if e.ComplexityRoot.ConcreteNodeA.ID == nil {
			break
		}

		return e.ComplexityRoot.ConcreteNodeA.ID(childComplexity), true

	case "ConcreteNodeA.name":
		if e.ComplexityRoot.ConcreteNodeA.Name == nil {
			break
		}

		return e.ComplexityRoot.ConcreteNodeA.Name(childComplexity), true

	case "ConcreteNodeInterface.child":
		if e.ComplexityRoot.ConcreteNodeInterface.Child == nil {
			break
		}

		return e.ComplexityRoot.ConcreteNodeInterface.Child(childComplexity), true

	case "ConcreteNodeInterface.id":
		if e.ComplexityRoot.ConcreteNodeInterface.ID == nil {
			break
		}

		return e.ComplexityRoot.ConcreteNodeInterface.ID(childComplexity), true

	case "Content_Post.foo":
		if e.ComplexityRoot.Content_Post.Foo == nil {
			break
		}

		return e.ComplexityRoot.Content_Post.Foo(childComplexity), true

	case "Content_User.foo":
		if e.ComplexityRoot.Content_User.Foo == nil {
			break
		}

		return e.ComplexityRoot.Content_User.Foo(childComplexity), true

	case "Coordinates.x":
		if e.ComplexityRoot.Coordinates.X == nil {
			break
		}

		return e.ComplexityRoot.Coordinates.X(childComplexity), true

	case "Coordinates.y":
		if e.ComplexityRoot.Coordinates.Y == nil {
			break
		}

		return e.ComplexityRoot.Coordinates.Y(childComplexity), true

	case "DefaultParametersMirror.falsyBoolean":
		if e.ComplexityRoot.DefaultParametersMirror.FalsyBoolean == nil {
			break
		}

		return e.ComplexityRoot.DefaultParametersMirror.FalsyBoolean(childComplexity), true

	case "DefaultParametersMirror.truthyBoolean":
		if e.ComplexityRoot.DefaultParametersMirror.TruthyBoolean == nil {
			break
		}

		return e.ComplexityRoot.DefaultParametersMirror.TruthyBoolean(childComplexity), true

	case "DeferModel.id":
		if e.ComplexityRoot.DeferModel.ID == nil {
			break
		}

		return e.ComplexityRoot.DeferModel.ID(childComplexity), true

	case "DeferModel.name":
		if e.ComplexityRoot.DeferModel.Name == nil {
			break
		}

		return e.ComplexityRoot.DeferModel.Name(childComplexity), true

	case "DeferModel.values":
		if e.ComplexityRoot.DeferModel.Values == nil {
			break
		}

		return e.ComplexityRoot.DeferModel.Values(childComplexity), true

	case "Dog.dogBreed":
		if e.ComplexityRoot.Dog.DogBreed == nil {
			break
		}

		return e.ComplexityRoot.Dog.DogBreed(childComplexity), true

	case "Dog.size":
		if e.ComplexityRoot.Dog.Size == nil {
			break
		}

		return e.ComplexityRoot.Dog.Size(childComplexity), true

	case "Dog.species":
		if e.ComplexityRoot.Dog.Species == nil {
			break
		}

		return e.ComplexityRoot.Dog.Species(childComplexity), true

	case "EmbeddedCase1.exportedEmbeddedPointerExportedMethod":
		if e.ComplexityRoot.EmbeddedCase1.ExportedEmbeddedPointerExportedMethod == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedCase1.ExportedEmbeddedPointerExportedMethod(childComplexity), true

	case "EmbeddedCase2.unexportedEmbeddedPointerExportedMethod":
		if e.ComplexityRoot.EmbeddedCase2.UnexportedEmbeddedPointerExportedMethod == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedCase2.UnexportedEmbeddedPointerExportedMethod(childComplexity), true

	case "EmbeddedCase3.unexportedEmbeddedInterfaceExportedMethod":
		if e.ComplexityRoot.EmbeddedCase3.UnexportedEmbeddedInterfaceExportedMethod == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedCase3.UnexportedEmbeddedInterfaceExportedMethod(childComplexity), true

	case "EmbeddedDefaultScalar.value":
		if e.ComplexityRoot.EmbeddedDefaultScalar.Value == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedDefaultScalar.Value(childComplexity), true

	case "EmbeddedPointer.ID":
		if e.ComplexityRoot.EmbeddedPointer.ID == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedPointer.ID(childComplexity), true

	case "EmbeddedPointer.Title":
		if e.ComplexityRoot.EmbeddedPointer.Title == nil {
			break
		}

		return e.ComplexityRoot.EmbeddedPointer.Title(childComplexity), true

	case "Error.errorOnNonRequiredField":
		if e.ComplexityRoot.Error.ErrorOnNonRequiredField == nil {
			break
		}

		return e.ComplexityRoot.Error.ErrorOnNonRequiredField(childComplexity), true

	case "Error.errorOnRequiredField":
		if e.ComplexityRoot.Error.ErrorOnRequiredField == nil {
			break
		}

		return e.ComplexityRoot.Error.ErrorOnRequiredField(childComplexity), true

	case "Error.id":
		if e.ComplexityRoot.Error.ID == nil {
			break
		}

		return e.ComplexityRoot.Error.ID(childComplexity), true

	case "Error.nilOnRequiredField":
		if e.ComplexityRoot.Error.NilOnRequiredField == nil {
			break
		}

		return e.ComplexityRoot.Error.NilOnRequiredField(childComplexity), true

	case "Errors.a":
		if e.ComplexityRoot.Errors.A == nil {
			break
		}

		return e.ComplexityRoot.Errors.A(childComplexity), true

	case "Errors.b":
		if e.ComplexityRoot.Errors.B == nil {
			break
		}

		return e.ComplexityRoot.Errors.B(childComplexity), true

	case "Errors.c":
		if e.ComplexityRoot.Errors.C == nil {
			break
		}

		return e.ComplexityRoot.Errors.C(childComplexity), true

	case "Errors.d":
		if e.ComplexityRoot.Errors.D == nil {
			break
		}

		return e.ComplexityRoot.Errors.D(childComplexity), true

	case "Errors.e":
		if e.ComplexityRoot.Errors.E == nil {
			break
		}

		return e.ComplexityRoot.Errors.E(childComplexity), true

	case "FieldsOrderPayload.firstFieldValue":
		if e.ComplexityRoot.FieldsOrderPayload.FirstFieldValue == nil {
			break
		}

		return e.ComplexityRoot.FieldsOrderPayload.FirstFieldValue(childComplexity), true

	case "ForcedResolver.field":
		if e.ComplexityRoot.ForcedResolver.Field == nil {
			break
		}

		return e.ComplexityRoot.ForcedResolver.Field(childComplexity), true

	case "Horse.horseBreed":
		if e.ComplexityRoot.Horse.HorseBreed == nil {
			break
		}

		return e.ComplexityRoot.Horse.HorseBreed(childComplexity), true

	case "Horse.size":
		if e.ComplexityRoot.Horse.Size == nil {
			break
		}

		return e.ComplexityRoot.Horse.Size(childComplexity), true

	case "Horse.species":
		if e.ComplexityRoot.Horse.Species == nil {
			break
		}

		return e.ComplexityRoot.Horse.Species(childComplexity), true

	case "InnerObject.id":
		if e.ComplexityRoot.InnerObject.ID == nil {
			break
		}

		return e.ComplexityRoot.InnerObject.ID(childComplexity), true

	case "InvalidIdentifier.id":
		if e.ComplexityRoot.InvalidIdentifier.ID == nil {
			break
		}

		return e.ComplexityRoot.InvalidIdentifier.ID(childComplexity), true

	case "It.id":
		if e.ComplexityRoot.It.ID == nil {
			break
		}

		return e.ComplexityRoot.It.ID(childComplexity), true

	case "LoopA.b":
		if e.ComplexityRoot.LoopA.B == nil {
			break
		}

		return e.ComplexityRoot.LoopA.B(childComplexity), true

	case "LoopB.a":
		if e.ComplexityRoot.LoopB.A == nil {
			break
		}

		return e.ComplexityRoot.LoopB.A(childComplexity), true

	case "Map.id":
		if e.ComplexityRoot.Map.ID == nil {
			break
		}

		return e.ComplexityRoot.Map.ID(childComplexity), true

	case "MapNested.value":
		if e.ComplexityRoot.MapNested.Value == nil {
			break
		}

		return e.ComplexityRoot.MapNested.Value(childComplexity), true

	case "MapStringInterfaceType.a":
		if e.ComplexityRoot.MapStringInterfaceType.A == nil {
			break
		}

		return e.ComplexityRoot.MapStringInterfaceType.A(childComplexity), true

	case "MapStringInterfaceType.b":
		if e.ComplexityRoot.MapStringInterfaceType.B == nil {
			break
		}

		return e.ComplexityRoot.MapStringInterfaceType.B(childComplexity), true

	case "MapStringInterfaceType.c":
		if e.ComplexityRoot.MapStringInterfaceType.C == nil {
			break
		}

		return e.ComplexityRoot.MapStringInterfaceType.C(childComplexity), true

	case "MapStringInterfaceType.nested":
		if e.ComplexityRoot.MapStringInterfaceType.Nested == nil {
			break
		}

		return e.ComplexityRoot.MapStringInterfaceType.Nested(childComplexity), true

	case "ModelMethods.noContext":
		if e.ComplexityRoot.ModelMethods.NoContext == nil {
			break
		}

		return e.ComplexityRoot.ModelMethods.NoContext(childComplexity), true

	case "ModelMethods.resolverField":
		if e.ComplexityRoot.ModelMethods.ResolverField == nil {
			break
		}

		return e.ComplexityRoot.ModelMethods.ResolverField(childComplexity), true

	case "ModelMethods.withContext":
		if e.ComplexityRoot.ModelMethods.WithContext == nil {
			break
		}

		return e.ComplexityRoot.ModelMethods.WithContext(childComplexity), true

	case "Mutation.defaultInput":
		if e.ComplexityRoot.Mutation.DefaultInput == nil {
			break
		}

		args, err := ec.field_Mutation_defaultInput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Mutation.DefaultInput(childComplexity, args["input"].(DefaultInput)), true

	case "Mutation.overrideValueViaInput":
		if e.ComplexityRoot.Mutation.OverrideValueViaInput == nil {
			break
		}

		args, err := ec.field_Mutation_overrideValueViaInput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Mutation.OverrideValueViaInput(childComplexity, args["input"].(FieldsOrderInput)), true

	case "Mutation.updateProduct":
		if e.ComplexityRoot.Mutation.UpdateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_updateProduct_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Mutation.UpdateProduct(childComplexity, args["id"].(string), args["name"].(*string), args["price"].(*float64)), true

	case "Mutation.updatePtrToPtr":
		if e.ComplexityRoot.Mutation.UpdatePtrToPtr == nil {
			break
		}

		args, err := ec.field_Mutation_updatePtrToPtr_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Mutation.UpdatePtrToPtr(childComplexity, args["input"].(UpdatePtrToPtrOuter)), true

	case "Mutation.updateSomething":
		if e.ComplexityRoot.Mutation.UpdateSomething == nil {
			break
		}

		args, err := ec.field_Mutation_updateSomething_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Mutation.UpdateSomething(childComplexity, args["input"].(SpecialInput)), true

	case "ObjectDirectives.nullableText":
		if e.ComplexityRoot.ObjectDirectives.NullableText == nil {
			break
		}

		return e.ComplexityRoot.ObjectDirectives.NullableText(childComplexity), true

	case "ObjectDirectives.order":
		if e.ComplexityRoot.ObjectDirectives.Order == nil {
			break
		}

		return e.ComplexityRoot.ObjectDirectives.Order(childComplexity), true

	case "ObjectDirectives.text":
		if e.ComplexityRoot.ObjectDirectives.Text == nil {
			break
		}

		return e.ComplexityRoot.ObjectDirectives.Text(childComplexity), true

	case "ObjectDirectivesWithCustomGoModel.nullableText":
		if e.ComplexityRoot.ObjectDirectivesWithCustomGoModel.NullableText == nil {
			break
		}

		return e.ComplexityRoot.ObjectDirectivesWithCustomGoModel.NullableText(childComplexity), true

	case "OuterObject.inner":
		if e.ComplexityRoot.OuterObject.Inner == nil {
			break
		}

		return e.ComplexityRoot.OuterObject.Inner(childComplexity), true

	case "OverlappingFields.oneFoo", "OverlappingFields.twoFoo":
		if e.ComplexityRoot.OverlappingFields.Foo == nil {
			break
		}

		return e.ComplexityRoot.OverlappingFields.Foo(childComplexity), true

	case "OverlappingFields.newFoo", "OverlappingFields.new_foo":
		if e.ComplexityRoot.OverlappingFields.NewFoo == nil {
			break
		}

		return e.ComplexityRoot.OverlappingFields.NewFoo(childComplexity), true

	case "OverlappingFields.oldFoo":
		if e.ComplexityRoot.OverlappingFields.OldFoo == nil {
			break
		}

		return e.ComplexityRoot.OverlappingFields.OldFoo(childComplexity), true

	case "Panics.argUnmarshal":
		if e.ComplexityRoot.Panics.ArgUnmarshal == nil {
			break
		}

		args, err := ec.field_Panics_argUnmarshal_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Panics.ArgUnmarshal(childComplexity, args["u"].([]MarshalPanic)), true

	case "Panics.fieldFuncMarshal":
		if e.ComplexityRoot.Panics.FieldFuncMarshal == nil {
			break
		}

		args, err := ec.field_Panics_fieldFuncMarshal_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Panics.FieldFuncMarshal(childComplexity, args["u"].([]MarshalPanic)), true

	case "Panics.fieldScalarMarshal":
		if e.ComplexityRoot.Panics.FieldScalarMarshal == nil {
			break
		}

		return e.ComplexityRoot.Panics.FieldScalarMarshal(childComplexity), true

	case "Pet.friends":
		if e.ComplexityRoot.Pet.Friends == nil {
			break
		}

		args, err := ec.field_Pet_friends_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Pet.Friends(childComplexity, args["limit"].(*int)), true

	case "Pet.id":
		if e.ComplexityRoot.Pet.ID == nil {
			break
		}

		return e.ComplexityRoot.Pet.ID(childComplexity), true

	case "Primitive.squared":
		if e.ComplexityRoot.Primitive.Squared == nil {
			break
		}

		return e.ComplexityRoot.Primitive.Squared(childComplexity), true

	case "Primitive.value":
		if e.ComplexityRoot.Primitive.Value == nil {
			break
		}

		return e.ComplexityRoot.Primitive.Value(childComplexity), true

	case "PrimitiveString.doubled":
		if e.ComplexityRoot.PrimitiveString.Doubled == nil {
			break
		}

		return e.ComplexityRoot.PrimitiveString.Doubled(childComplexity), true

	case "PrimitiveString.len":
		if e.ComplexityRoot.PrimitiveString.Len == nil {
			break
		}

		return e.ComplexityRoot.PrimitiveString.Len(childComplexity), true

	case "PrimitiveString.value":
		if e.ComplexityRoot.PrimitiveString.Value == nil {
			break
		}

		return e.ComplexityRoot.PrimitiveString.Value(childComplexity), true

	case "PtrToAnyContainer.binding":
		if e.ComplexityRoot.PtrToAnyContainer.Binding == nil {
			break
		}

		return e.ComplexityRoot.PtrToAnyContainer.Binding(childComplexity), true

	case "PtrToAnyContainer.ptrToAny":
		if e.ComplexityRoot.PtrToAnyContainer.PtrToAny == nil {
			break
		}

		return e.ComplexityRoot.PtrToAnyContainer.PtrToAny(childComplexity), true

	case "PtrToPtrInner.key":
		if e.ComplexityRoot.PtrToPtrInner.Key == nil {
			break
		}

		return e.ComplexityRoot.PtrToPtrInner.Key(childComplexity), true

	case "PtrToPtrInner.value":
		if e.ComplexityRoot.PtrToPtrInner.Value == nil {
			break
		}

		return e.ComplexityRoot.PtrToPtrInner.Value(childComplexity), true

	case "PtrToPtrOuter.inner":
		if e.ComplexityRoot.PtrToPtrOuter.Inner == nil {
			break
		}

		return e.ComplexityRoot.PtrToPtrOuter.Inner(childComplexity), true

	case "PtrToPtrOuter.name":
		if e.ComplexityRoot.PtrToPtrOuter.Name == nil {
			break
		}

		return e.ComplexityRoot.PtrToPtrOuter.Name(childComplexity), true

	case "PtrToPtrOuter.stupidInner":
		if e.ComplexityRoot.PtrToPtrOuter.StupidInner == nil {
			break
		}

		return e.ComplexityRoot.PtrToPtrOuter.StupidInner(childComplexity), true

	case "PtrToSliceContainer.ptrToSlice":
		if e.ComplexityRoot.PtrToSliceContainer.PtrToSlice == nil {
			break
		}

		return e.ComplexityRoot.PtrToSliceContainer.PtrToSlice(childComplexity), true

	case "Query.animal":
		if e.ComplexityRoot.Query.Animal == nil {
			break
		}

		return e.ComplexityRoot.Query.Animal(childComplexity), true

	case "Query.autobind":
		if e.ComplexityRoot.Query.Autobind == nil {
			break
		}

		return e.ComplexityRoot.Query.Autobind(childComplexity), true

	case "Query.collision":
		if e.ComplexityRoot.Query.Collision == nil {
			break
		}

		return e.ComplexityRoot.Query.Collision(childComplexity), true

	case "Query.defaultParameters":
		if e.ComplexityRoot.Query.DefaultParameters == nil {
			break
		}

		args, err := ec.field_Query_defaultParameters_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DefaultParameters(childComplexity, args["falsyBoolean"].(*bool), args["truthyBoolean"].(*bool)), true

	case "Query.defaultScalar":
		if e.ComplexityRoot.Query.DefaultScalar == nil {
			break
		}

		args, err := ec.field_Query_defaultScalar_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DefaultScalar(childComplexity, args["arg"].(string)), true

	case "Query.deferMultiple":
		if e.ComplexityRoot.Query.DeferMultiple == nil {
			break
		}

		return e.ComplexityRoot.Query.DeferMultiple(childComplexity), true

	case "Query.deferSingle":
		if e.ComplexityRoot.Query.DeferSingle == nil {
			break
		}

		return e.ComplexityRoot.Query.DeferSingle(childComplexity), true

	case "Query.deprecatedField":
		if e.ComplexityRoot.Query.DeprecatedField == nil {
			break
		}

		return e.ComplexityRoot.Query.DeprecatedField(childComplexity), true

	case "Query.directiveArg":
		if e.ComplexityRoot.Query.DirectiveArg == nil {
			break
		}

		args, err := ec.field_Query_directiveArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveArg(childComplexity, args["arg"].(string)), true

	case "Query.directiveDouble":
		if e.ComplexityRoot.Query.DirectiveDouble == nil {
			break
		}

		return e.ComplexityRoot.Query.DirectiveDouble(childComplexity), true

	case "Query.directiveField":
		if e.ComplexityRoot.Query.DirectiveField == nil {
			break
		}

		return e.ComplexityRoot.Query.DirectiveField(childComplexity), true

	case "Query.directiveFieldDef":
		if e.ComplexityRoot.Query.DirectiveFieldDef == nil {
			break
		}

		args, err := ec.field_Query_directiveFieldDef_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveFieldDef(childComplexity, args["ret"].(string)), true

	case "Query.directiveInput":
		if e.ComplexityRoot.Query.DirectiveInput == nil {
			break
		}

		args, err := ec.field_Query_directiveInput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveInput(childComplexity, args["arg"].(InputDirectives)), true

	case "Query.directiveInputNullable":
		if e.ComplexityRoot.Query.DirectiveInputNullable == nil {
			break
		}

		args, err := ec.field_Query_directiveInputNullable_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveInputNullable(childComplexity, args["arg"].(*InputDirectives)), true

	case "Query.directiveInputType":
		if e.ComplexityRoot.Query.DirectiveInputType == nil {
			break
		}

		args, err := ec.field_Query_directiveInputType_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveInputType(childComplexity, args["arg"].(InnerInput)), true

	case "Query.directiveNullableArg":
		if e.ComplexityRoot.Query.DirectiveNullableArg == nil {
			break
		}

		args, err := ec.field_Query_directiveNullableArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveNullableArg(childComplexity, args["arg"].(*int), args["arg2"].(*int), args["arg3"].(*string)), true

	case "Query.directiveObject":
		if e.ComplexityRoot.Query.DirectiveObject == nil {
			break
		}

		return e.ComplexityRoot.Query.DirectiveObject(childComplexity), true

	case "Query.directiveObjectWithCustomGoModel":
		if e.ComplexityRoot.Query.DirectiveObjectWithCustomGoModel == nil {
			break
		}

		return e.ComplexityRoot.Query.DirectiveObjectWithCustomGoModel(childComplexity), true

	case "Query.directiveSingleNullableArg":
		if e.ComplexityRoot.Query.DirectiveSingleNullableArg == nil {
			break
		}

		args, err := ec.field_Query_directiveSingleNullableArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.DirectiveSingleNullableArg(childComplexity, args["arg1"].(*string)), true

	case "Query.directiveUnimplemented":
		if e.ComplexityRoot.Query.DirectiveUnimplemented == nil {
			break
		}

		return e.ComplexityRoot.Query.DirectiveUnimplemented(childComplexity), true

	case "Query.dog":
		if e.ComplexityRoot.Query.Dog == nil {
			break
		}

		return e.ComplexityRoot.Query.Dog(childComplexity), true

	case "Query.embeddedCase1":
		if e.ComplexityRoot.Query.EmbeddedCase1 == nil {
			break
		}

		return e.ComplexityRoot.Query.EmbeddedCase1(childComplexity), true

	case "Query.embeddedCase2":
		if e.ComplexityRoot.Query.EmbeddedCase2 == nil {
			break
		}

		return e.ComplexityRoot.Query.EmbeddedCase2(childComplexity), true

	case "Query.embeddedCase3":
		if e.ComplexityRoot.Query.EmbeddedCase3 == nil {
			break
		}

		return e.ComplexityRoot.Query.EmbeddedCase3(childComplexity), true

	case "Query.enumInInput":
		if e.ComplexityRoot.Query.EnumInInput == nil {
			break
		}

		args, err := ec.field_Query_enumInInput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.EnumInInput(childComplexity, args["input"].(*InputWithEnumValue)), true

	case "Query.errorBubble":
		if e.ComplexityRoot.Query.ErrorBubble == nil {
			break
		}

		return e.ComplexityRoot.Query.ErrorBubble(childComplexity), true

	case "Query.errorBubbleList":
		if e.ComplexityRoot.Query.ErrorBubbleList == nil {
			break
		}

		return e.ComplexityRoot.Query.ErrorBubbleList(childComplexity), true

	case "Query.errorList":
		if e.ComplexityRoot.Query.ErrorList == nil {
			break
		}

		return e.ComplexityRoot.Query.ErrorList(childComplexity), true

	case "Query.errors":
		if e.ComplexityRoot.Query.Errors == nil {
			break
		}

		return e.ComplexityRoot.Query.Errors(childComplexity), true

	case "Query.fallback":
		if e.ComplexityRoot.Query.Fallback == nil {
			break
		}

		args, err := ec.field_Query_fallback_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.Fallback(childComplexity, args["arg"].(FallbackToStringEncoding)), true

	case "Query.fieldWithDeprecatedArg":
		if e.ComplexityRoot.Query.FieldWithDeprecatedArg == nil {
			break
		}

		args, err := ec.field_Query_fieldWithDeprecatedArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.FieldWithDeprecatedArg(childComplexity, args["oldArg"].(*int), args["newArg"].(*int)), true

	case "Query.filterProducts":
		if e.ComplexityRoot.Query.FilterProducts == nil {
			break
		}

		args, err := ec.field_Query_filterProducts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.FilterProducts(childComplexity, args["query"].(*string), args["category"].(*string), args["minPrice"].(*int)), true

	case "Query.findProducts":
		if e.ComplexityRoot.Query.FindProducts == nil {
			break
		}

		args, err := ec.field_Query_findProducts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.FindProducts(childComplexity, args["query"].(*string), args["category"].(*string), args["minPrice"].(*int)), true

	case "Query.infinity":
		if e.ComplexityRoot.Query.Infinity == nil {
			break
		}

		return e.ComplexityRoot.Query.Infinity(childComplexity), true

	case "Query.inputNullableSlice":
		if e.ComplexityRoot.Query.InputNullableSlice == nil {
			break
		}

		args, err := ec.field_Query_inputNullableSlice_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.InputNullableSlice(childComplexity, args["arg"].([]string)), true

	case "Query.inputOmittable":
		if e.ComplexityRoot.Query.InputOmittable == nil {
			break
		}

		args, err := ec.field_Query_inputOmittable_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.InputOmittable(childComplexity, args["arg"].(OmittableInput)), true

	case "Query.inputSlice":
		if e.ComplexityRoot.Query.InputSlice == nil {
			break
		}

		args, err := ec.field_Query_inputSlice_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.InputSlice(childComplexity, args["arg"].([]string)), true

	case "Query.invalid":
		if e.ComplexityRoot.Query.Invalid == nil {
			break
		}

		return e.ComplexityRoot.Query.Invalid(childComplexity), true

	case "Query.invalidIdentifier":
		if e.ComplexityRoot.Query.InvalidIdentifier == nil {
			break
		}

		return e.ComplexityRoot.Query.InvalidIdentifier(childComplexity), true

	case "Query.issue896a":
		if e.ComplexityRoot.Query.Issue896a == nil {
			break
		}

		return e.ComplexityRoot.Query.Issue896a(childComplexity), true

	case "Query.mapInput":
		if e.ComplexityRoot.Query.MapInput == nil {
			break
		}

		args, err := ec.field_Query_mapInput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.MapInput(childComplexity, args["input"].(map[string]any)), true

	case "Query.mapNestedMapSlice":
		if e.ComplexityRoot.Query.MapNestedMapSlice == nil {
			break
		}

		args, err := ec.field_Query_mapNestedMapSlice_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.MapNestedMapSlice(childComplexity, args["input"].(map[string]any)), true

	case "Query.mapNestedStringInterface":
		if e.ComplexityRoot.Query.MapNestedStringInterface == nil {
			break
		}

		args, err := ec.field_Query_mapNestedStringInterface_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.MapNestedStringInterface(childComplexity, args["in"].(*NestedMapInput)), true

	case "Query.mapStringInterface":
		if e.ComplexityRoot.Query.MapStringInterface == nil {
			break
		}

		args, err := ec.field_Query_mapStringInterface_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.MapStringInterface(childComplexity, args["in"].(map[string]any)), true

	case "Query.modelMethods":
		if e.ComplexityRoot.Query.ModelMethods == nil {
			break
		}

		return e.ComplexityRoot.Query.ModelMethods(childComplexity), true

	case "Query.nestedInputs":
		if e.ComplexityRoot.Query.NestedInputs == nil {
			break
		}

		args, err := ec.field_Query_nestedInputs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.NestedInputs(childComplexity, args["input"].([][]*OuterInput)), true

	case "Query.nestedOutputs":
		if e.ComplexityRoot.Query.NestedOutputs == nil {
			break
		}

		return e.ComplexityRoot.Query.NestedOutputs(childComplexity), true

	case "Query.noShape":
		if e.ComplexityRoot.Query.NoShape == nil {
			break
		}

		return e.ComplexityRoot.Query.NoShape(childComplexity), true

	case "Query.noShapeTypedNil":
		if e.ComplexityRoot.Query.NoShapeTypedNil == nil {
			break
		}

		return e.ComplexityRoot.Query.NoShapeTypedNil(childComplexity), true

	case "Query.node":
		if e.ComplexityRoot.Query.Node == nil {
			break
		}

		return e.ComplexityRoot.Query.Node(childComplexity), true

	case "Query.notAnInterface":
		if e.ComplexityRoot.Query.NotAnInterface == nil {
			break
		}

		return e.ComplexityRoot.Query.NotAnInterface(childComplexity), true

	case "Query.nullableArg":
		if e.ComplexityRoot.Query.NullableArg == nil {
			break
		}

		args, err := ec.field_Query_nullableArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.NullableArg(childComplexity, args["arg"].(*int)), true

	case "Query.optionalUnion":
		if e.ComplexityRoot.Query.OptionalUnion == nil {
			break
		}

		return e.ComplexityRoot.Query.OptionalUnion(childComplexity), true

	case "Query.overlapping":
		if e.ComplexityRoot.Query.Overlapping == nil {
			break
		}

		return e.ComplexityRoot.Query.Overlapping(childComplexity), true

	case "Query.panics":
		if e.ComplexityRoot.Query.Panics == nil {
			break
		}

		return e.ComplexityRoot.Query.Panics(childComplexity), true

	case "Query.primitiveObject":
		if e.ComplexityRoot.Query.PrimitiveObject == nil {
			break
		}

		return e.ComplexityRoot.Query.PrimitiveObject(childComplexity), true

	case "Query.primitiveStringObject":
		if e.ComplexityRoot.Query.PrimitiveStringObject == nil {
			break
		}

		return e.ComplexityRoot.Query.PrimitiveStringObject(childComplexity), true

	case "Query.ptrToAnyContainer":
		if e.ComplexityRoot.Query.PtrToAnyContainer == nil {
			break
		}

		return e.ComplexityRoot.Query.PtrToAnyContainer(childComplexity), true

	case "Query.ptrToSliceContainer":
		if e.ComplexityRoot.Query.PtrToSliceContainer == nil {
			break
		}

		return e.ComplexityRoot.Query.PtrToSliceContainer(childComplexity), true

	case "Query.recursive":
		if e.ComplexityRoot.Query.Recursive == nil {
			break
		}

		args, err := ec.field_Query_recursive_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.Recursive(childComplexity, args["input"].(*RecursiveInputSlice)), true

	case "Query.scalarSlice":
		if e.ComplexityRoot.Query.ScalarSlice == nil {
			break
		}

		return e.ComplexityRoot.Query.ScalarSlice(childComplexity), true

	case "Query.searchMixed":
		if e.ComplexityRoot.Query.SearchMixed == nil {
			break
		}

		args, err := ec.field_Query_searchMixed_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchMixed(childComplexity, args["query"].(*string), args["category"].(*string), args["minPrice"].(*int), args["limit"].(*int), args["offset"].(*int), args["sortBy"].(*string)), true

	case "Query.searchProducts":
		if e.ComplexityRoot.Query.SearchProducts == nil {
			break
		}

		args, err := ec.field_Query_searchProducts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchProducts(childComplexity, args["query"].(*string), args["category"].(*string), args["minPrice"].(*int)), true

	case "Query.searchProductsNormal":
		if e.ComplexityRoot.Query.SearchProductsNormal == nil {
			break
		}

		args, err := ec.field_Query_searchProductsNormal_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchProductsNormal(childComplexity, args["filters"].(map[string]any)), true

	case "Query.searchRequired":
		if e.ComplexityRoot.Query.SearchRequired == nil {
			break
		}

		args, err := ec.field_Query_searchRequired_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchRequired(childComplexity, args["name"].(string), args["age"].(int)), true

	case "Query.searchWithDefaults":
		if e.ComplexityRoot.Query.SearchWithDefaults == nil {
			break
		}

		args, err := ec.field_Query_searchWithDefaults_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchWithDefaults(childComplexity, args["query"].(*string), args["limit"].(*int), args["includeArchived"].(*bool)), true

	case "Query.searchWithDirectives":
		if e.ComplexityRoot.Query.SearchWithDirectives == nil {
			break
		}

		args, err := ec.field_Query_searchWithDirectives_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.SearchWithDirectives(childComplexity, args["oldField"].(*string), args["newField"].(*string)), true

	case "Query.shapeUnion":
		if e.ComplexityRoot.Query.ShapeUnion == nil {
			break
		}

		return e.ComplexityRoot.Query.ShapeUnion(childComplexity), true

	case "Query.shapes":
		if e.ComplexityRoot.Query.Shapes == nil {
			break
		}

		return e.ComplexityRoot.Query.Shapes(childComplexity), true

	case "Query.skipInclude":
		if e.ComplexityRoot.Query.SkipInclude == nil {
			break
		}

		return e.ComplexityRoot.Query.SkipInclude(childComplexity), true

	case "Query.slices":
		if e.ComplexityRoot.Query.Slices == nil {
			break
		}

		return e.ComplexityRoot.Query.Slices(childComplexity), true

	case "Query.stringFromContextFunction":
		if e.ComplexityRoot.Query.StringFromContextFunction == nil {
			break
		}

		return e.ComplexityRoot.Query.StringFromContextFunction(childComplexity), true

	case "Query.stringFromContextInterface":
		if e.ComplexityRoot.Query.StringFromContextInterface == nil {
			break
		}

		return e.ComplexityRoot.Query.StringFromContextInterface(childComplexity), true

	case "Query.user":
		if e.ComplexityRoot.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.User(childComplexity, args["id"].(int)), true

	case "Query.vOkCaseNil":
		if e.ComplexityRoot.Query.VOkCaseNil == nil {
			break
		}

		return e.ComplexityRoot.Query.VOkCaseNil(childComplexity), true

	case "Query.vOkCaseValue":
		if e.ComplexityRoot.Query.VOkCaseValue == nil {
			break
		}

		return e.ComplexityRoot.Query.VOkCaseValue(childComplexity), true

	case "Query.valid":
		if e.ComplexityRoot.Query.Valid == nil {
			break
		}

		return e.ComplexityRoot.Query.Valid(childComplexity), true

	case "Query.validType":
		if e.ComplexityRoot.Query.ValidType == nil {
			break
		}

		return e.ComplexityRoot.Query.ValidType(childComplexity), true

	case "Query.variadicModel":
		if e.ComplexityRoot.Query.VariadicModel == nil {
			break
		}

		return e.ComplexityRoot.Query.VariadicModel(childComplexity), true

	case "Query.wrappedMap":
		if e.ComplexityRoot.Query.WrappedMap == nil {
			break
		}

		return e.ComplexityRoot.Query.WrappedMap(childComplexity), true

	case "Query.wrappedScalar":
		if e.ComplexityRoot.Query.WrappedScalar == nil {
			break
		}

		return e.ComplexityRoot.Query.WrappedScalar(childComplexity), true

	case "Query.wrappedSlice":
		if e.ComplexityRoot.Query.WrappedSlice == nil {
			break
		}

		return e.ComplexityRoot.Query.WrappedSlice(childComplexity), true

	case "Query.wrappedStruct":
		if e.ComplexityRoot.Query.WrappedStruct == nil {
			break
		}

		return e.ComplexityRoot.Query.WrappedStruct(childComplexity), true

	case "Rectangle.area":
		if e.ComplexityRoot.Rectangle.Area == nil {
			break
		}

		return e.ComplexityRoot.Rectangle.Area(childComplexity), true

	case "Rectangle.coordinates":
		if e.ComplexityRoot.Rectangle.Coordinates == nil {
			break
		}

		return e.ComplexityRoot.Rectangle.Coordinates(childComplexity), true

	case "Rectangle.length":
		if e.ComplexityRoot.Rectangle.Length == nil {
			break
		}

		return e.ComplexityRoot.Rectangle.Length(childComplexity), true

	case "Rectangle.width":
		if e.ComplexityRoot.Rectangle.Width == nil {
			break
		}

		return e.ComplexityRoot.Rectangle.Width(childComplexity), true

	case "Size.height":
		if e.ComplexityRoot.Size.Height == nil {
			break
		}

		return e.ComplexityRoot.Size.Height(childComplexity), true

	case "Size.weight":
		if e.ComplexityRoot.Size.Weight == nil {
			break
		}

		return e.ComplexityRoot.Size.Weight(childComplexity), true

	case "SkipIncludeTestType.a":
		if e.ComplexityRoot.SkipIncludeTestType.A == nil {
			break
		}

		return e.ComplexityRoot.SkipIncludeTestType.A(childComplexity), true

	case "SkipIncludeTestType.b":
		if e.ComplexityRoot.SkipIncludeTestType.B == nil {
			break
		}

		return e.ComplexityRoot.SkipIncludeTestType.B(childComplexity), true

	case "Slices.test1":
		if e.ComplexityRoot.Slices.Test1 == nil {
			break
		}

		return e.ComplexityRoot.Slices.Test1(childComplexity), true

	case "Slices.test2":
		if e.ComplexityRoot.Slices.Test2 == nil {
			break
		}

		return e.ComplexityRoot.Slices.Test2(childComplexity), true

	case "Slices.test3":
		if e.ComplexityRoot.Slices.Test3 == nil {
			break
		}

		return e.ComplexityRoot.Slices.Test3(childComplexity), true

	case "Slices.test4":
		if e.ComplexityRoot.Slices.Test4 == nil {
			break
		}

		return e.ComplexityRoot.Slices.Test4(childComplexity), true

	case "Subscription.directiveArg":
		if e.ComplexityRoot.Subscription.DirectiveArg == nil {
			break
		}

		args, err := ec.field_Subscription_directiveArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Subscription.DirectiveArg(childComplexity, args["arg"].(string)), true

	case "Subscription.directiveDouble":
		if e.ComplexityRoot.Subscription.DirectiveDouble == nil {
			break
		}

		return e.ComplexityRoot.Subscription.DirectiveDouble(childComplexity), true

	case "Subscription.directiveNullableArg":
		if e.ComplexityRoot.Subscription.DirectiveNullableArg == nil {
			break
		}

		args, err := ec.field_Subscription_directiveNullableArg_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Subscription.DirectiveNullableArg(childComplexity, args["arg"].(*int), args["arg2"].(*int), args["arg3"].(*string)), true

	case "Subscription.directiveUnimplemented":
		if e.ComplexityRoot.Subscription.DirectiveUnimplemented == nil {
			break
		}

		return e.ComplexityRoot.Subscription.DirectiveUnimplemented(childComplexity), true

	case "Subscription.errorRequired":
		if e.ComplexityRoot.Subscription.ErrorRequired == nil {
			break
		}

		return e.ComplexityRoot.Subscription.ErrorRequired(childComplexity), true

	case "Subscription.initPayload":
		if e.ComplexityRoot.Subscription.InitPayload == nil {
			break
		}

		return e.ComplexityRoot.Subscription.InitPayload(childComplexity), true

	case "Subscription.issue896b":
		if e.ComplexityRoot.Subscription.Issue896b == nil {
			break
		}

		return e.ComplexityRoot.Subscription.Issue896b(childComplexity), true

	case "Subscription.updated":
		if e.ComplexityRoot.Subscription.Updated == nil {
			break
		}

		return e.ComplexityRoot.Subscription.Updated(childComplexity), true

	case "User.created":
		if e.ComplexityRoot.User.Created == nil {
			break
		}

		return e.ComplexityRoot.User.Created(childComplexity), true

	case "User.friends":
		if e.ComplexityRoot.User.Friends == nil {
			break
		}

		return e.ComplexityRoot.User.Friends(childComplexity), true

	case "User.id":
		if e.ComplexityRoot.User.ID == nil {
			break
		}

		return e.ComplexityRoot.User.ID(childComplexity), true

	case "User.pets":
		if e.ComplexityRoot.User.Pets == nil {
			break
		}

		args, err := ec.field_User_pets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.User.Pets(childComplexity, args["limit"].(*int)), true

	case "User.updated":
		if e.ComplexityRoot.User.Updated == nil {
			break
		}

		return e.ComplexityRoot.User.Updated(childComplexity), true

	case "VOkCaseNil.value":
		if e.ComplexityRoot.VOkCaseNil.Value == nil {
			break
		}

		return e.ComplexityRoot.VOkCaseNil.Value(childComplexity), true

	case "VOkCaseValue.value":
		if e.ComplexityRoot.VOkCaseValue.Value == nil {
			break
		}

		return e.ComplexityRoot.VOkCaseValue.Value(childComplexity), true

	case "ValidType.differentCase":
		if e.ComplexityRoot.ValidType.DifferentCase == nil {
			break
		}

		return e.ComplexityRoot.ValidType.DifferentCase(childComplexity), true

	case "ValidType.different_case":
		if e.ComplexityRoot.ValidType.DifferentCaseOld == nil {
			break
		}

		return e.ComplexityRoot.ValidType.DifferentCaseOld(childComplexity), true

	case "ValidType.validArgs":
		if e.ComplexityRoot.ValidType.ValidArgs == nil {
			break
		}

		args, err := ec.field_ValidType_validArgs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.ValidType.ValidArgs(childComplexity, args["break"].(string), args["default"].(string), args["func"].(string), args["interface"].(string), args["select"].(string), args["case"].(string), args["defer"].(string), args["go"].(string), args["map"].(string), args["struct"].(string), args["chan"].(string), args["else"].(string), args["goto"].(string), args["package"].(string), args["switch"].(string), args["const"].(string), args["fallthrough"].(string), args["if"].(string), args["range"].(string), args["type"].(string), args["continue"].(string), args["for"].(string), args["import"].(string), args["return"].(string), args["var"].(string), args["_"].(string)), true

	case "ValidType.validInputKeywords":
		if e.ComplexityRoot.ValidType.ValidInputKeywords == nil {
			break
		}

		args, err := ec.field_ValidType_validInputKeywords_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.ValidType.ValidInputKeywords(childComplexity, args["input"].(*ValidInput)), true

	case "VariadicModel.value":
		if e.ComplexityRoot.VariadicModel.Value == nil {
			break
		}

		args, err := ec.field_VariadicModel_value_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.VariadicModel.Value(childComplexity, args["rank"].(int)), true

	case "WrappedMap.get":
		if e.ComplexityRoot.WrappedMap.Get == nil {
			break
		}

		args, err := ec.field_WrappedMap_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.WrappedMap.Get(childComplexity, args["key"].(string)), true

	case "WrappedSlice.get":
		if e.ComplexityRoot.WrappedSlice.Get == nil {
			break
		}

		args, err := ec.field_WrappedSlice_get_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.WrappedSlice.Get(childComplexity, args["idx"].(int)), true

	case "WrappedStruct.desc":
		if e.ComplexityRoot.WrappedStruct.Desc == nil {
			break
		}

		return e.ComplexityRoot.WrappedStruct.Desc(childComplexity), true

	case "WrappedStruct.name":
		if e.ComplexityRoot.WrappedStruct.Name == nil {
			break
		}

		return e.ComplexityRoot.WrappedStruct.Name(childComplexity), true

	case "XXIt.id":
		if e.ComplexityRoot.XXIt.ID == nil {
			break
		}

		return e.ComplexityRoot.XXIt.ID(childComplexity), true

	case "XxIt.id":
		if e.ComplexityRoot.XxIt.ID == nil {
			break
		}

		return e.ComplexityRoot.XxIt.ID(childComplexity), true

	case "asdfIt.id":
		if e.ComplexityRoot.AsdfIt.ID == nil {
			break
		}

		return e.ComplexityRoot.AsdfIt.ID(childComplexity), true

	case "iIt.id":
		if e.ComplexityRoot.IIt.ID == nil {
			break
		}

		return e.ComplexityRoot.IIt.ID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := newExecutionContext(opCtx, e, make(chan graphql.DeferredResult))
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputChanges,
		ec.unmarshalInputDefaultInput,
		ec.unmarshalInputDirectiveInput,
		ec.unmarshalInputFieldsOrderInput,
		ec.unmarshalInputInnerDirectives,
		ec.unmarshalInputInnerInput,
		ec.unmarshalInputInputDirectives,
		ec.unmarshalInputInputWithEnumValue,
		ec.unmarshalInputMapNestedInput,
		ec.unmarshalInputMapNestedMapSliceInput,
		ec.unmarshalInputMapStringInterfaceInput,
		ec.unmarshalInputNestedInput,
		ec.unmarshalInputNestedMapInput,
		ec.unmarshalInputOmittableInput,
		ec.unmarshalInputOuterInput,
		ec.unmarshalInputRecursiveInputSlice,
		ec.unmarshalInputRequiredFilters,
		ec.unmarshalInputSearchFilters,
		ec.unmarshalInputSearchWithDefaults,
		ec.unmarshalInputSpecialInput,
		ec.unmarshalInputUpdateProductInput,
		ec.unmarshalInputUpdatePtrToPtrInner,
		ec.unmarshalInputUpdatePtrToPtrOuter,
		ec.unmarshalInputValidInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.PendingDeferred) > 0 {
					result := <-ec.DeferredResults
					atomic.AddInt32(&ec.PendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.Deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.PendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.ExecutionContextState[ResolverRoot, DirectiveRoot, ComplexityRoot]
}

func newExecutionContext(
	opCtx *graphql.OperationContext,
	execSchema *executableSchema,
	deferredResults chan graphql.DeferredResult,
) executionContext {
	return executionContext{
		ExecutionContextState: graphql.NewExecutionContextState[ResolverRoot, DirectiveRoot, ComplexityRoot](
			opCtx,
			(*graphql.ExecutableSchemaState[ResolverRoot, DirectiveRoot, ComplexityRoot])(execSchema),
			parsedSchema,
			deferredResults,
		),
	}
}

var sources = []*ast.Source{
	{Name: "inline_arguments_transformed_schema.graphql", Input: `directive @custom on ARGUMENT_DEFINITION
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @directive1 on FIELD_DEFINITION
directive @directive2 on FIELD_DEFINITION
directive @directive3 on INPUT_OBJECT
directive @goField(forceResolver: Boolean, name: String, omittable: Boolean, type: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
directive @inlineArguments on ARGUMENT_DEFINITION
directive @length(min: Int!, max: Int, message: String) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @logged(id: UUID!) on FIELD
directive @makeNil on FIELD_DEFINITION
directive @makeTypedNil on FIELD_DEFINITION
directive @noop on ARGUMENT_DEFINITION
directive @order1(location: String!) repeatable on FIELD_DEFINITION | OBJECT
directive @order2(location: String!) on OBJECT
directive @populate(value: String!) on ARGUMENT_DEFINITION
directive @range(min: Int = 0, max: Int) on ARGUMENT_DEFINITION
directive @toNull on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | FIELD_DEFINITION
directive @unimplemented on FIELD_DEFINITION
type A {
	id: ID!
}
type AIt {
	id: ID!
}
type AbIt {
	id: ID!
}
interface Animal {
	species: String!
	size: Size!
}
scalar Any
type Autobind {
	int: Int!
	int32: Int!
	int64: Int!
	idStr: ID!
	idInt: ID!
}
type B {
	id: ID!
}
type BackedByInterface {
	id: String!
	thisShouldBind: String!
	thisShouldBindWithError: String!
}
scalar Bytes
type Cat implements Animal {
	species: String!
	size: Size!
	catBreed: String!
}
input Changes @goModel(model: "map[string]interface{}") {
	a: Int
	b: Int
}
type CheckIssue896 {
	id: Int
}
type Circle implements Shape {
	radius: Float
	area: Float
	coordinates: Coordinates
}
type ConcreteNodeA implements Node {
	id: ID!
	child: Node!
	name: String!
}
"""
 Implements the Node interface with another interface 
"""
type ConcreteNodeInterface implements Node {
	id: ID!
	child: Node!
}
union Content_Child = Content_User | Content_Post
type Content_Post {
	foo: String
}
type Content_User {
	foo: String
}
type Coordinates {
	x: Float!
	y: Float!
}
scalar CustomScalar @goModel(model: "followschema.CustomScalar")
input DefaultInput {
	falsyBoolean: Boolean = false
	truthyBoolean: Boolean = true
}
type DefaultParametersMirror {
	falsyBoolean: Boolean
	truthyBoolean: Boolean
}
"""
 This doesnt have an implementation in the typemap, so it should act like a string 
"""
scalar DefaultScalarImplementation
type DeferModel {
	id: ID!
	name: String!
	values: [String!]! @goField(forceResolver: true)
}
input DirectiveInput @goModel(model: "map[string]interface{}") {
	oldField: String @deprecated(reason: "Use newField instead")
	newField: String
}
type Dog implements Animal {
	species: String!
	size: Size!
	dogBreed: String!
}
scalar Email
type EmbeddedCase1 @goModel(model: "followschema.EmbeddedCase1") {
	exportedEmbeddedPointerExportedMethod: String!
}
type EmbeddedCase2 @goModel(model: "followschema.EmbeddedCase2") {
	unexportedEmbeddedPointerExportedMethod: String!
}
type EmbeddedCase3 @goModel(model: "followschema.EmbeddedCase3") {
	unexportedEmbeddedInterfaceExportedMethod: String!
}
type EmbeddedDefaultScalar {
	value: DefaultScalarImplementation
}
type EmbeddedPointer @goModel(model: "followschema.EmbeddedPointerModel") {
	ID: String
	Title: String
}
enum EnumTest {
	OK
	NG
}
type Error {
	id: ID!
	errorOnNonRequiredField: String
	errorOnRequiredField: String!
	nilOnRequiredField: String!
}
type Errors {
	a: Error!
	b: Error!
	c: Error!
	d: Error!
	e: Error!
}
enum FallbackToStringEncoding {
	A
	B
	C
}
input FieldsOrderInput {
	firstField: String
	overrideFirstField: String
}
type FieldsOrderPayload {
	firstFieldValue: String
}
type ForcedResolver {
	field: Circle @goField(forceResolver: true)
}
type Horse implements Mammalian & Animal {
	species: String!
	size: Size!
	horseBreed: String!
}
input InnerDirectives {
	message: String! @length(min: 1, message: "not valid")
}
input InnerInput {
	id: Int!
}
type InnerObject {
	id: Int!
}
input InputDirectives @directive3 {
	text: String! @length(min: 0, max: 7, message: "not valid")
	nullableText: String @toNull
	inner: InnerDirectives!
	innerNullable: InnerDirectives
	thirdParty: ThirdParty @length(min: 0, max: 7)
}
input InputWithEnumValue {
	enum: EnumTest!
}
type InvalidIdentifier {
	id: Int!
}
type It {
	id: ID!
}
type LoopA {
	b: LoopB!
}
type LoopB {
	a: LoopA!
}
interface Mammalian implements Animal {
	species: String!
	size: Size!
}
"""
Since gqlgen defines default implementation for a Map scalar, this tests that the builtin is _not_
added to the TypeMap
"""
type Map {
	id: ID!
}
type MapNested @goModel(model: "followschema.MapNested") {
	value: CustomScalar!
}
input MapNestedInput @goModel(model: "followschema.MapNested") {
	value: CustomScalar!
}
input MapNestedMapSliceInput @goModel(model: "map[string]interface{}") {
	name: String
	recurse: [MapNestedMapSliceInput!]
}
input MapStringInterfaceInput @goModel(model: "map[string]interface{}") {
	a: String!
	b: Int
	c: CustomScalar
	nested: MapNestedInput
}
type MapStringInterfaceType @goModel(model: "map[string]interface{}") {
	a: String
	b: Int
	c: CustomScalar
	nested: MapNested
}
scalar MarshalPanic
type ModelMethods {
	resolverField: Boolean!
	noContext: Boolean!
	withContext: Boolean!
}
type Mutation {
	defaultInput(input: DefaultInput!): DefaultParametersMirror!
	overrideValueViaInput(input: FieldsOrderInput!): FieldsOrderPayload!
	updateProduct(id: ID!, name: String, price: Float): String!
	updateSomething(input: SpecialInput!): String!
	updatePtrToPtr(input: UpdatePtrToPtrOuter!): PtrToPtrOuter!
}
input NestedInput {
	field: Email!
}
input NestedMapInput {
	map: MapStringInterfaceInput
}
interface Node {
	id: ID!
	child: Node!
}
type ObjectDirectives @order1(location: "order1_1") @order1(location: "order1_2") @order2(location: "order2_1") {
	text: String! @length(min: 0, max: 7, message: "not valid")
	nullableText: String @toNull
	order: [String!]!
}
type ObjectDirectivesWithCustomGoModel {
	nullableText: String @toNull
}
input OmittableInput {
	id: ID @goField(omittable: true)
	bool: Boolean @goField(omittable: true)
	str: String @goField(omittable: true)
	int: Int @goField(omittable: true)
	time: Time @goField(omittable: true)
	enum: Status @goField(omittable: true)
	scalar: ThirdParty @goField(omittable: true)
	object: OuterInput @goField(omittable: true)
}
input OuterInput {
	inner: InnerInput!
}
type OuterObject {
	inner: InnerObject!
}
type OverlappingFields {
	oneFoo: Int! @goField(name: "foo")
	twoFoo: Int! @goField(name: "foo")
	oldFoo: Int! @goField(name: "foo", forceResolver: true)
	newFoo: Int!
	new_foo: Int!
}
type Panics {
	fieldScalarMarshal: [MarshalPanic!]!
	fieldFuncMarshal(u: [MarshalPanic!]!): [MarshalPanic!]!
	argUnmarshal(u: [MarshalPanic!]!): Boolean!
}
type Pet {
	id: Int!
	friends(limit: Int): [Pet!] @goField(forceResolver: true)
}
type Primitive {
	value: Int!
	squared: Int!
}
type PrimitiveString {
	value: String!
	doubled: String!
	len: Int!
}
type PtrToAnyContainer {
	ptrToAny: Any
	binding: Any
}
type PtrToPtrInner {
	key: String!
	value: String!
}
type PtrToPtrOuter {
	name: String!
	inner: PtrToPtrInner
	stupidInner: PtrToPtrInner
}
type PtrToSliceContainer {
	ptrToSlice: [String!]
}
type Query {
	invalidIdentifier: InvalidIdentifier
	collision: It
	mapInput(input: Changes): Boolean
	recursive(input: RecursiveInputSlice): Boolean
	nestedInputs(input: [[OuterInput]] = [[{inner:{id:1}}]]): Boolean
	nestedOutputs: [[OuterObject]]
	modelMethods: ModelMethods
	user(id: Int!): User!
	nullableArg(arg: Int = 123): String
	inputSlice(arg: [String!]!): Boolean!
	inputNullableSlice(arg: [String!]): Boolean!
	inputOmittable(arg: OmittableInput!): String!
	shapeUnion: ShapeUnion!
	autobind: Autobind
	deprecatedField: String! @deprecated(reason: "test deprecated directive")
	fieldWithDeprecatedArg(oldArg: Int @deprecated(reason: "old arg"), newArg: Int): String
	overlapping: OverlappingFields
	defaultParameters(falsyBoolean: Boolean = false, truthyBoolean: Boolean = true): DefaultParametersMirror!
	deferSingle: DeferModel
	deferMultiple: [DeferModel!]
	directiveArg(arg: String! @length(min: 1, max: 255, message: "invalid length")): String
	directiveNullableArg(arg: Int @range(min: 0), arg2: Int @range, arg3: String @toNull): String
	directiveSingleNullableArg(arg1: String @populate(value: "test") @noop): String
	directiveInputNullable(arg: InputDirectives): String
	directiveInput(arg: InputDirectives!): String
	directiveInputType(arg: InnerInput! @custom): String
	directiveObject: ObjectDirectives @order1(location: "Query_field")
	directiveObjectWithCustomGoModel: ObjectDirectivesWithCustomGoModel
	directiveFieldDef(ret: String!): String! @length(min: 1, message: "not valid")
	directiveField: String
	directiveDouble: String @directive1 @directive2
	directiveUnimplemented: String @unimplemented
	embeddedCase1: EmbeddedCase1
	embeddedCase2: EmbeddedCase2
	embeddedCase3: EmbeddedCase3
	enumInInput(input: InputWithEnumValue): EnumTest!
	searchProducts(query: String, category: String, minPrice: Int): [String!]!
	searchRequired(name: String!, age: Int!): [String!]!
	searchProductsNormal(filters: SearchFilters): [String!]!
	searchWithDefaults(query: String = "default search", limit: Int = 20, includeArchived: Boolean = false): [String!]!
	searchMixed(query: String, category: String, minPrice: Int, limit: Int = 10, offset: Int = 0, sortBy: String): [String!]!
	filterProducts(query: String, category: String, minPrice: Int): [String!]!
	findProducts(query: String, category: String, minPrice: Int): [String!]!
	searchWithDirectives(oldField: String @deprecated(reason: "Use newField instead"), newField: String): [String!]!
	shapes: [Shape]
	noShape: Shape @makeNil
	node: Node!
	noShapeTypedNil: Shape @makeTypedNil
	animal: Animal @makeTypedNil
	notAnInterface: BackedByInterface
	dog: Dog
	issue896a: [CheckIssue896!]
	mapStringInterface(in: MapStringInterfaceInput): MapStringInterfaceType
	mapNestedStringInterface(in: NestedMapInput): MapStringInterfaceType
	mapNestedMapSlice(input: MapNestedMapSliceInput): Boolean
	errorBubble: Error
	errorBubbleList: [Error!]
	errorList: [Error]
	errors: Errors
	valid: String!
	invalid: String!
	panics: Panics
	primitiveObject: [Primitive!]!
	primitiveStringObject: [PrimitiveString!]!
	ptrToAnyContainer: PtrToAnyContainer!
	ptrToSliceContainer: PtrToSliceContainer!
	infinity: Float!
	stringFromContextInterface: StringFromContextInterface!
	stringFromContextFunction: StringFromContextFunction!
	defaultScalar(arg: DefaultScalarImplementation! = "default"): DefaultScalarImplementation!
	skipInclude: SkipIncludeTestType
	slices: Slices
	scalarSlice: Bytes!
	fallback(arg: FallbackToStringEncoding!): FallbackToStringEncoding!
	optionalUnion: TestUnion
	vOkCaseValue: VOkCaseValue
	vOkCaseNil: VOkCaseNil
	validType: ValidType
	variadicModel: VariadicModel
	wrappedStruct: WrappedStruct!
	wrappedScalar: WrappedScalar!
	wrappedMap: WrappedMap!
	wrappedSlice: WrappedSlice!
}
type Rectangle implements Shape {
	length: Float
	width: Float
	area: Float
	coordinates: Coordinates
}
input RecursiveInputSlice {
	self: [RecursiveInputSlice!]
}
input RequiredFilters @goModel(model: "map[string]interface{}") {
	name: String!
	age: Int!
}
input SearchFilters @goModel(model: "map[string]interface{}") {
	query: String
	category: String
	minPrice: Int
}
input SearchWithDefaults @goModel(model: "map[string]interface{}") {
	query: String = "default search"
	limit: Int = 20
	includeArchived: Boolean = false
}
interface Shape {
	area: Float
	coordinates: Coordinates
}
union ShapeUnion @goModel(model: "followschema.ShapeUnion") = Circle | Rectangle
type Size {
	height: Int!
	weight: Int!
}
type SkipIncludeTestType {
	a: String
	b: String
}
type Slices {
	test1: [String]
	test2: [String!]
	test3: [String]!
	test4: [String!]!
}
input SpecialInput {
	nesting: NestedInput!
}
enum Status {
	OK
	ERROR
}
scalar StringFromContextFunction
scalar StringFromContextInterface
type Subscription {
	updated: String!
	initPayload: String!
	directiveArg(arg: String! @length(min: 1, max: 255, message: "invalid length")): String
	directiveNullableArg(arg: Int @range(min: 0), arg2: Int @range, arg3: String @toNull): String
	directiveDouble: String @directive1 @directive2
	directiveUnimplemented: String @unimplemented
	issue896b: [CheckIssue896]
	errorRequired: Error!
}
union TestUnion = A | B
scalar ThirdParty @goModel(model: "followschema.ThirdParty")
scalar Time
scalar UUID
input UpdateProductInput @goModel(model: "map[string]interface{}") {
	id: ID!
	name: String
	price: Float
}
input UpdatePtrToPtrInner {
	key: String
	value: String
}
input UpdatePtrToPtrOuter {
	name: String
	inner: UpdatePtrToPtrInner
	stupidInner: UpdatePtrToPtrInner
}
type User {
	id: Int!
	friends: [User!]! @goField(forceResolver: true)
	created: Time!
	updated: Time
	pets(limit: Int): [Pet!] @goField(forceResolver: true)
}
type VOkCaseNil @goModel(model: "followschema.VOkCaseNil") {
	value: String
}
type VOkCaseValue @goModel(model: "followschema.VOkCaseValue") {
	value: String
}
input ValidInput {
	break: String!
	default: String!
	func: String!
	interface: String!
	select: String!
	case: String!
	defer: String!
	go: String!
	map: String!
	struct: String!
	chan: String!
	else: String!
	goto: String!
	package: String!
	switch: String!
	const: String!
	fallthrough: String!
	if: String!
	range: String!
	type: String!
	continue: String!
	for: String!
	import: String!
	return: String!
	var: String!
	_: String! @goField(name: "Underscore")
}
"""
 These things are all valid, but without care generate invalid go code 
"""
type ValidType {
	differentCase: String!
	different_case: String! @goField(name: "DifferentCaseOld")
	validInputKeywords(input: ValidInput): Boolean!
	validArgs(break: String!, default: String!, func: String!, interface: String!, select: String!, case: String!, defer: String!, go: String!, map: String!, struct: String!, chan: String!, else: String!, goto: String!, package: String!, switch: String!, const: String!, fallthrough: String!, if: String!, range: String!, type: String!, continue: String!, for: String!, import: String!, return: String!, var: String!, _: String!): Boolean!
}
type VariadicModel {
	value(rank: Int!): String
}
type WrappedMap {
	get(key: String!): String!
}
scalar WrappedScalar
type WrappedSlice {
	get(idx: Int!): String!
}
type WrappedStruct {
	name: WrappedScalar!
	desc: WrappedScalar
}
type XXIt {
	id: ID!
}
type XxIt {
	id: ID!
}
type asdfIt {
	id: ID!
}
type iIt {
	id: ID!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
