// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package splitpackages

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/executor/shardruntime"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Query struct {
		Hello func(childComplexity int, name string) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Query.hello":
		if e.complexity.Query.Hello == nil {
			break
		}

		args, err := ec.field_Query_hello_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hello(childComplexity, args["name"].(string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

func (ec *executionContext) GetOperationContext() *graphql.OperationContext {
	return ec.OperationContext
}

func (ec *executionContext) ProcessDeferredGroup(dg graphql.DeferredGroup) {
	ec.processDeferredGroup(dg)
}

func (ec *executionContext) AddDeferred(delta int32) {
	atomic.AddInt32(&ec.deferred, delta)
}

func (ec *executionContext) ResolveField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, obj any) graphql.Marshaler {
	switch objectName + "." + fieldName {
	case "Query.hello":
		return ec._Query_hello(ctx, field)
	case "Query.__type":
		return ec._Query___type(ctx, field)
	case "Query.__schema":
		return ec._Query___schema(ctx, field)
	case "__Directive.name":
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ec.___Directive_name(ctx, field, typedObj)
	case "__Directive.description":
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ec.___Directive_description(ctx, field, typedObj)
	case "__Directive.isRepeatable":
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ec.___Directive_isRepeatable(ctx, field, typedObj)
	case "__Directive.locations":
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ec.___Directive_locations(ctx, field, typedObj)
	case "__Directive.args":
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ec.___Directive_args(ctx, field, typedObj)
	case "__EnumValue.name":
		typedObj, ok := obj.(*introspection.EnumValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __EnumValue", obj))
		}
		return ec.___EnumValue_name(ctx, field, typedObj)
	case "__EnumValue.description":
		typedObj, ok := obj.(*introspection.EnumValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __EnumValue", obj))
		}
		return ec.___EnumValue_description(ctx, field, typedObj)
	case "__EnumValue.isDeprecated":
		typedObj, ok := obj.(*introspection.EnumValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __EnumValue", obj))
		}
		return ec.___EnumValue_isDeprecated(ctx, field, typedObj)
	case "__EnumValue.deprecationReason":
		typedObj, ok := obj.(*introspection.EnumValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __EnumValue", obj))
		}
		return ec.___EnumValue_deprecationReason(ctx, field, typedObj)
	case "__Field.name":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_name(ctx, field, typedObj)
	case "__Field.description":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_description(ctx, field, typedObj)
	case "__Field.args":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_args(ctx, field, typedObj)
	case "__Field.type":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_type(ctx, field, typedObj)
	case "__Field.isDeprecated":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_isDeprecated(ctx, field, typedObj)
	case "__Field.deprecationReason":
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ec.___Field_deprecationReason(ctx, field, typedObj)
	case "__InputValue.name":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_name(ctx, field, typedObj)
	case "__InputValue.description":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_description(ctx, field, typedObj)
	case "__InputValue.type":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_type(ctx, field, typedObj)
	case "__InputValue.defaultValue":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_defaultValue(ctx, field, typedObj)
	case "__InputValue.isDeprecated":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_isDeprecated(ctx, field, typedObj)
	case "__InputValue.deprecationReason":
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ec.___InputValue_deprecationReason(ctx, field, typedObj)
	case "__Schema.description":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_description(ctx, field, typedObj)
	case "__Schema.types":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_types(ctx, field, typedObj)
	case "__Schema.queryType":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_queryType(ctx, field, typedObj)
	case "__Schema.mutationType":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_mutationType(ctx, field, typedObj)
	case "__Schema.subscriptionType":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_subscriptionType(ctx, field, typedObj)
	case "__Schema.directives":
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ec.___Schema_directives(ctx, field, typedObj)
	case "__Type.kind":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_kind(ctx, field, typedObj)
	case "__Type.name":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_name(ctx, field, typedObj)
	case "__Type.description":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_description(ctx, field, typedObj)
	case "__Type.specifiedByURL":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_specifiedByURL(ctx, field, typedObj)
	case "__Type.fields":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_fields(ctx, field, typedObj)
	case "__Type.interfaces":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_interfaces(ctx, field, typedObj)
	case "__Type.possibleTypes":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_possibleTypes(ctx, field, typedObj)
	case "__Type.enumValues":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_enumValues(ctx, field, typedObj)
	case "__Type.inputFields":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_inputFields(ctx, field, typedObj)
	case "__Type.ofType":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_ofType(ctx, field, typedObj)
	case "__Type.isOneOf":
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ec.___Type_isOneOf(ctx, field, typedObj)
	default:
		panic(fmt.Sprintf("unknown field %s.%s", objectName, fieldName))
	}
}

func (ec *executionContext) ResolveStreamField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, _ any) func(ctx context.Context) graphql.Marshaler {
	switch objectName + "." + fieldName {
	default:
		panic(fmt.Sprintf("unknown stream field %s.%s", objectName, fieldName))
	}
}
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "Query")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "Query"))
	}
	return handler(ctx, ec, sel, nil)
}
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__Directive")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__Directive"))
	}
	return handler(ctx, ec, sel, obj)
}
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__EnumValue")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__EnumValue"))
	}
	return handler(ctx, ec, sel, obj)
}
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__Field")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__Field"))
	}
	return handler(ctx, ec, sel, obj)
}
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__InputValue")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__InputValue"))
	}
	return handler(ctx, ec, sel, obj)
}
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__Schema")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__Schema"))
	}
	return handler(ctx, ec, sel, obj)
}
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	handler, ok := shardruntime.LookupObject("github.com/99designs/gqlgen/codegen/testserver/splitpackages", "__Type")
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", "__Type"))
	}
	return handler(ctx, ec, sel, obj)
}

//go:embed "schema.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphql", Input: sourceData("schema.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
