[
  {
    "name": "Validate: Argument values of correct type/Valid values/Good int value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: 2)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Good boolean value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            booleanArgField(booleanArg: true)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Good string value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringArgField(stringArg: \"foo\")\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Good float value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            floatArgField(floatArg: 1.1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Int into Float",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            floatArgField(floatArg: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Int into ID",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            idArgField(idArg: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/String into ID",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            idArgField(idArg: \"someIdString\")\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Good enum value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: SIT)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Enum with undefined value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            enumArgField(enumArg: UNKNOWN)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/Enum with null value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            enumArgField(enumArg: NO_FUR)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/null into nullable type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: null)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid values/null into nullable type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog(a: null, b: null, c:{ requiredField: true, intField: null }) {\n            name\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Invalid String values/Int into String",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringArgField(stringArg: 1)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringArg\" has invalid value 1.\nExpected type \"String\", found 1.",
        "locations": [
          {
            "line": 4,
            "column": 39
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid String values/Float into String",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringArgField(stringArg: 1.0)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringArg\" has invalid value 1.0.\nExpected type \"String\", found 1.0.",
        "locations": [
          {
            "line": 4,
            "column": 39
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid String values/Boolean into String",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringArgField(stringArg: true)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringArg\" has invalid value true.\nExpected type \"String\", found true.",
        "locations": [
          {
            "line": 4,
            "column": 39
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid String values/Unquoted String into String",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringArgField(stringArg: BAR)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringArg\" has invalid value BAR.\nExpected type \"String\", found BAR.",
        "locations": [
          {
            "line": 4,
            "column": 39
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Int values/String into Int",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: \"3\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"intArg\" has invalid value \"3\".\nExpected type \"Int\", found \"3\".",
        "locations": [
          {
            "line": 4,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Int values/Big Int into Int",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: 829384293849283498239482938)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"intArg\" has invalid value 829384293849283498239482938.\nExpected type \"Int\", found 829384293849283498239482938.",
        "locations": [
          {
            "line": 4,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Int values/Unquoted String into Int",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: FOO)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"intArg\" has invalid value FOO.\nExpected type \"Int\", found FOO.",
        "locations": [
          {
            "line": 4,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Int values/Simple Float into Int",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: 3.0)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"intArg\" has invalid value 3.0.\nExpected type \"Int\", found 3.0.",
        "locations": [
          {
            "line": 4,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Int values/Float into Int",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            intArgField(intArg: 3.333)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"intArg\" has invalid value 3.333.\nExpected type \"Int\", found 3.333.",
        "locations": [
          {
            "line": 4,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Float values/String into Float",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            floatArgField(floatArg: \"3.333\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"floatArg\" has invalid value \"3.333\".\nExpected type \"Float\", found \"3.333\".",
        "locations": [
          {
            "line": 4,
            "column": 37
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Float values/Boolean into Float",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            floatArgField(floatArg: true)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"floatArg\" has invalid value true.\nExpected type \"Float\", found true.",
        "locations": [
          {
            "line": 4,
            "column": 37
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Float values/Unquoted into Float",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            floatArgField(floatArg: FOO)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"floatArg\" has invalid value FOO.\nExpected type \"Float\", found FOO.",
        "locations": [
          {
            "line": 4,
            "column": 37
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Boolean value/Int into Boolean",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            booleanArgField(booleanArg: 2)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"booleanArg\" has invalid value 2.\nExpected type \"Boolean\", found 2.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Boolean value/Float into Boolean",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            booleanArgField(booleanArg: 1.0)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"booleanArg\" has invalid value 1.0.\nExpected type \"Boolean\", found 1.0.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Boolean value/String into Boolean",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            booleanArgField(booleanArg: \"true\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"booleanArg\" has invalid value \"true\".\nExpected type \"Boolean\", found \"true\".",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Boolean value/Unquoted into Boolean",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            booleanArgField(booleanArg: TRUE)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"booleanArg\" has invalid value TRUE.\nExpected type \"Boolean\", found TRUE.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid ID value/Float into ID",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            idArgField(idArg: 1.0)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"idArg\" has invalid value 1.0.\nExpected type \"ID\", found 1.0.",
        "locations": [
          {
            "line": 4,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid ID value/Boolean into ID",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            idArgField(idArg: true)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"idArg\" has invalid value true.\nExpected type \"ID\", found true.",
        "locations": [
          {
            "line": 4,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid ID value/Unquoted into ID",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            idArgField(idArg: SOMETHING)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"idArg\" has invalid value SOMETHING.\nExpected type \"ID\", found SOMETHING.",
        "locations": [
          {
            "line": 4,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/Int into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: 2)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value 2.\nExpected type \"DogCommand\", found 2.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/Float into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: 1.0)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value 1.0.\nExpected type \"DogCommand\", found 1.0.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/String into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: \"SIT\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value \"SIT\".\nExpected type \"DogCommand\", found \"SIT\".",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/Boolean into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: true)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value true.\nExpected type \"DogCommand\", found true.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/Unknown Enum Value into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: JUGGLE)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value JUGGLE.\nExpected type \"DogCommand\", found JUGGLE.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid Enum value/Different case Enum Value into Enum",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            doesKnowCommand(dogCommand: sit)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"dogCommand\" has invalid value sit.\nExpected type \"DogCommand\", found sit.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Valid List value/Good list value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: [\"one\", null, \"two\"])\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid List value/Empty list value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: [])\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid List value/Null value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: null)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid List value/Single value into List",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: \"one\")\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Invalid List value/Incorrect item type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: [\"one\", 2])\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringListArg\" has invalid value [\"one\", 2].\nIn element #1: Expected type \"String\", found 2.",
        "locations": [
          {
            "line": 4,
            "column": 47
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid List value/Single value of incorrect type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            stringListArgField(stringListArg: 1)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"stringListArg\" has invalid value 1.\nExpected type \"String\", found 1.",
        "locations": [
          {
            "line": 4,
            "column": 47
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Arg on optional arg",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            isHousetrained(atOtherHomes: true)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/No Arg on optional arg",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog {\n            isHousetrained\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Multiple args",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req1: 1, req2: 2)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Multiple args reverse order",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req2: 2, req1: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/No args on multiple optional",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/One arg on multiple optional",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts(opt1: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Second arg on multiple optional",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts(opt2: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Multiple reqs on mixedList",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/Multiple reqs and one opt on mixedList",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4, opt1: 5)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid non-nullable value/All reqs and opts on mixedList",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4, opt1: 5, opt2: 6)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Invalid non-nullable value/Incorrect value type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req2: \"two\", req1: \"one\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"req2\" has invalid value \"two\".\nExpected type \"Int\", found \"two\".",
        "locations": [
          {
            "line": 4,
            "column": 32
          }
        ]
      },
      {
        "message": "Argument \"req1\" has invalid value \"one\".\nExpected type \"Int\", found \"one\".",
        "locations": [
          {
            "line": 4,
            "column": 45
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid non-nullable value/Incorrect value and missing argument",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req1: \"one\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"req1\" has invalid value \"one\".\nExpected type \"Int\", found \"one\".",
        "locations": [
          {
            "line": 4,
            "column": 32
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid non-nullable value/Null value",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req1: null)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"req1\" has invalid value null.\nExpected \"Int!\", found null.",
        "locations": [
          {
            "line": 4,
            "column": 32
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Optional arg, despite required field in type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Partial object, only required",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: { requiredField: true })\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Partial object, required field can be falsey",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: { requiredField: false })\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Partial object, including required",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: { requiredField: true, intField: 4 })\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Full object",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: {\n              requiredField: true,\n              intField: 4,\n              stringField: \"foo\",\n              booleanField: false,\n              stringListField: [\"one\", \"two\"]\n            })\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Valid input object value/Full object with fields in different order",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: {\n              stringListField: [\"one\", \"two\"],\n              booleanField: false,\n              requiredField: true,\n              stringField: \"foo\",\n              intField: 4,\n            })\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Invalid input object value/Partial object, missing required",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: { intField: 4 })\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"complexArg\" has invalid value {intField: 4}.\nIn field \"requiredField\": Expected \"Boolean!\", found null.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid input object value/Partial object, invalid field type",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: {\n              stringListField: [\"one\", 2],\n              requiredField: true,\n            })\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"complexArg\" has invalid value {stringListField: [\"one\", 2], requiredField: true}.\nIn field \"stringListField\": In element #1: Expected type \"String\", found 2.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Invalid input object value/Partial object, unknown field arg",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          complicatedArgs {\n            complexArgField(complexArg: {\n              requiredField: true,\n              unknownField: \"value\"\n            })\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"complexArg\" has invalid value {requiredField: true, unknownField: \"value\"}.\nIn field \"unknownField\": Unknown field.",
        "locations": [
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Argument values of correct type/Directive arguments/with directives of valid types",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog @include(if: true) {\n            name\n          }\n          human @skip(if: false) {\n            name\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Argument values of correct type/Directive arguments/with directive with incorrect types",
    "rule": "ArgumentsOfCorrectType",
    "query": "\n        {\n          dog @include(if: \"yes\") {\n            name @skip(if: ENUM)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Argument \"if\" has invalid value \"yes\".\nExpected type \"Boolean\", found \"yes\".",
        "locations": [
          {
            "line": 3,
            "column": 28
          }
        ]
      },
      {
        "message": "Argument \"if\" has invalid value ENUM.\nExpected type \"Boolean\", found ENUM.",
        "locations": [
          {
            "line": 4,
            "column": 28
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variable default values of correct type/variables with no default values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query NullableValues($a: Int, $b: String, $c: ComplexInput) {\n        dog { name }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variable default values of correct type/required variables without default values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query RequiredValues($a: Int!, $b: String!) {\n        dog { name }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variable default values of correct type/variables with valid default values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query WithDefaultValues(\n        $a: Int = 1,\n        $b: String = \"ok\",\n        $c: ComplexInput = { requiredField: true, intField: 3 }\n      ) {\n        dog { name }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variable default values of correct type/variables with valid default null values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query WithDefaultValues(\n        $a: Int = null,\n        $b: String = null,\n        $c: ComplexInput = { requiredField: true, intField: null }\n      ) {\n        dog { name }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variable default values of correct type/variables with invalid default null values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query WithDefaultValues(\n        $a: Int! = null,\n        $b: String! = null,\n        $c: ComplexInput = { requiredField: null, intField: null }\n      ) {\n        dog { name }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" of type \"Int!\" is required and will not use the default value. Perhaps you meant to use type \"Int\".",
        "locations": [
          {
            "line": 3,
            "column": 20
          }
        ]
      },
      {
        "message": "Variable \"$a\" of type \"Int!\" has invalid default value null.\nExpected \"Int!\", found null.",
        "locations": [
          {
            "line": 3,
            "column": 20
          }
        ]
      },
      {
        "message": "Variable \"$b\" of type \"String!\" is required and will not use the default value. Perhaps you meant to use type \"String\".",
        "locations": [
          {
            "line": 4,
            "column": 23
          }
        ]
      },
      {
        "message": "Variable \"$b\" of type \"String!\" has invalid default value null.\nExpected \"String!\", found null.",
        "locations": [
          {
            "line": 4,
            "column": 23
          }
        ]
      },
      {
        "message": "Variable \"$c\" of type \"ComplexInput\" has invalid default value {requiredField: null, intField: null}.\nIn field \"requiredField\": Expected \"Boolean!\", found null.",
        "locations": [
          {
            "line": 5,
            "column": 28
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variable default values of correct type/no required variables with default values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query UnreachableDefaultValues($a: Int! = 3, $b: String! = \"default\") {\n        dog { name }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" of type \"Int!\" is required and will not use the default value. Perhaps you meant to use type \"Int\".",
        "locations": [
          {
            "line": 2,
            "column": 49
          }
        ]
      },
      {
        "message": "Variable \"$b\" of type \"String!\" is required and will not use the default value. Perhaps you meant to use type \"String\".",
        "locations": [
          {
            "line": 2,
            "column": 66
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variable default values of correct type/variables with invalid default values",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query InvalidDefaultValues(\n        $a: Int = \"one\",\n        $b: String = 4,\n        $c: ComplexInput = \"notverycomplex\"\n      ) {\n        dog { name }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" of type \"Int\" has invalid default value \"one\".\nExpected type \"Int\", found \"one\".",
        "locations": [
          {
            "line": 3,
            "column": 19
          }
        ]
      },
      {
        "message": "Variable \"$b\" of type \"String\" has invalid default value 4.\nExpected type \"String\", found 4.",
        "locations": [
          {
            "line": 4,
            "column": 22
          }
        ]
      },
      {
        "message": "Variable \"$c\" of type \"ComplexInput\" has invalid default value \"notverycomplex\".\nExpected \"ComplexInput\", found not an object.",
        "locations": [
          {
            "line": 5,
            "column": 28
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variable default values of correct type/complex variables missing required field",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query MissingRequiredField($a: ComplexInput = {intField: 3}) {\n        dog { name }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" of type \"ComplexInput\" has invalid default value {intField: 3}.\nIn field \"requiredField\": Expected \"Boolean!\", found null.",
        "locations": [
          {
            "line": 2,
            "column": 53
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variable default values of correct type/list variables with invalid item",
    "rule": "DefaultValuesOfCorrectType",
    "query": "\n      query InvalidItem($a: [String] = [\"one\", 2]) {\n        dog { name }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" of type \"[String]\" has invalid default value [\"one\", 2].\nIn element #1: Expected type \"String\", found 2.",
        "locations": [
          {
            "line": 2,
            "column": 40
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Object field selection",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment objectFieldSelection on Dog {\n        __typename\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Aliased object field selection",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment aliasedObjectFieldSelection on Dog {\n        tn : __typename\n        otherName : name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Interface field selection",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment interfaceFieldSelection on Pet {\n        __typename\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Aliased interface field selection",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment interfaceFieldSelection on Pet {\n        otherName : name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Lying alias selection",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment lyingAliasSelection on Dog {\n        name : nickname\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Ignores fields on unknown type",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment unknownSelection on UnknownType {\n        unknownField\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/reports errors when type is known again",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment typeKnownAgain on Pet {\n        unknown_pet_field {\n          ... on Cat {\n            unknown_cat_field\n          }\n        }\n      }",
    "errors": [
      {
        "message": "Cannot query field \"unknown_pet_field\" on type \"Pet\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      },
      {
        "message": "Cannot query field \"unknown_cat_field\" on type \"Cat\".",
        "locations": [
          {
            "line": 5,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Field not defined on fragment",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment fieldNotDefined on Dog {\n        meowVolume\n      }",
    "errors": [
      {
        "message": "Cannot query field \"meowVolume\" on type \"Dog\". Did you mean \"barkVolume\"?",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Ignores deeply unknown field",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment deepFieldNotDefined on Dog {\n        unknown_field {\n          deeper_unknown_field\n        }\n      }",
    "errors": [
      {
        "message": "Cannot query field \"unknown_field\" on type \"Dog\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Sub-field not defined",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment subFieldNotDefined on Human {\n        pets {\n          unknown_field\n        }\n      }",
    "errors": [
      {
        "message": "Cannot query field \"unknown_field\" on type \"Pet\".",
        "locations": [
          {
            "line": 4,
            "column": 11
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Field not defined on inline fragment",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment fieldNotDefined on Pet {\n        ... on Dog {\n          meowVolume\n        }\n      }",
    "errors": [
      {
        "message": "Cannot query field \"meowVolume\" on type \"Dog\". Did you mean \"barkVolume\"?",
        "locations": [
          {
            "line": 4,
            "column": 11
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Aliased field target not defined",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment aliasedFieldTargetNotDefined on Dog {\n        volume : mooVolume\n      }",
    "errors": [
      {
        "message": "Cannot query field \"mooVolume\" on type \"Dog\". Did you mean \"barkVolume\"?",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Aliased lying field target not defined",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment aliasedLyingFieldTargetNotDefined on Dog {\n        barkVolume : kawVolume\n      }",
    "errors": [
      {
        "message": "Cannot query field \"kawVolume\" on type \"Dog\". Did you mean \"barkVolume\"?",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Not defined on interface",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment notDefinedOnInterface on Pet {\n        tailLength\n      }",
    "errors": [
      {
        "message": "Cannot query field \"tailLength\" on type \"Pet\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Defined on implementors but not on interface",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment definedOnImplementorsButNotInterface on Pet {\n        nickname\n      }",
    "errors": [
      {
        "message": "Cannot query field \"nickname\" on type \"Pet\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Meta field selection on union",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment directFieldSelectionOnUnion on CatOrDog {\n        __typename\n      }",
    "errors": []
  },
  {
    "name": "Validate: Fields on correct type/Direct field selection on union",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment directFieldSelectionOnUnion on CatOrDog {\n        directField\n      }",
    "errors": [
      {
        "message": "Cannot query field \"directField\" on type \"CatOrDog\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/Defined on implementors queried on union",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment definedOnImplementorsQueriedOnUnion on CatOrDog {\n        name\n      }",
    "errors": [
      {
        "message": "Cannot query field \"name\" on type \"CatOrDog\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fields on correct type/valid field in inline fragment",
    "rule": "FieldsOnCorrectType",
    "query": "\n      fragment objectFieldSelection on Pet {\n        ... on Dog {\n          name\n        }\n        ... {\n          name\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/object is valid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment validFragment on Dog {\n        barks\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/interface is valid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment validFragment on Pet {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/object is valid inline fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment validFragment on Pet {\n        ... on Dog {\n          barks\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/inline fragment without type is valid",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment validFragment on Pet {\n        ... {\n          name\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/union is valid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment validFragment on CatOrDog {\n        __typename\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Fragments on composite types/scalar is invalid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment scalarFragment on Boolean {\n        bad\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"scalarFragment\" cannot condition on non composite type \"Boolean\".",
        "locations": [
          {
            "line": 2,
            "column": 34
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fragments on composite types/enum is invalid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment scalarFragment on FurColor {\n        bad\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"scalarFragment\" cannot condition on non composite type \"FurColor\".",
        "locations": [
          {
            "line": 2,
            "column": 34
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fragments on composite types/input object is invalid fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment inputFragment on ComplexInput {\n        stringField\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"inputFragment\" cannot condition on non composite type \"ComplexInput\".",
        "locations": [
          {
            "line": 2,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Fragments on composite types/scalar is invalid inline fragment type",
    "rule": "FragmentsOnCompositeTypes",
    "query": "\n      fragment invalidFragment on Pet {\n        ... on String {\n          barks\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Fragment cannot condition on non composite type \"String\".",
        "locations": [
          {
            "line": 3,
            "column": 16
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known argument names/single arg is known",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment argOnRequiredArg on Dog {\n        doesKnowCommand(dogCommand: SIT)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/multiple args are known",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment multipleArgs on ComplicatedArgs {\n        multipleReqs(req1: 1, req2: 2)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/ignores args of unknown fields",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment argOnUnknownField on Dog {\n        unknownField(unknownArg: SIT)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/multiple args in reverse order are known",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment multipleArgsReverseOrder on ComplicatedArgs {\n        multipleReqs(req2: 2, req1: 1)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/no args on optional arg",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment noArgOnOptionalArg on Dog {\n        isHousetrained\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/args are known deeply",
    "rule": "KnownArgumentNames",
    "query": "\n      {\n        dog {\n          doesKnowCommand(dogCommand: SIT)\n        }\n        human {\n          pet {\n            ... on Dog {\n              doesKnowCommand(dogCommand: SIT)\n            }\n          }\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/directive args are known",
    "rule": "KnownArgumentNames",
    "query": "\n      {\n        dog @skip(if: true)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known argument names/undirective args are invalid",
    "rule": "KnownArgumentNames",
    "query": "\n      {\n        dog @skip(unless: true)\n      }\n    ",
    "errors": [
      {
        "message": "Unknown argument \"unless\" on directive \"@skip\".",
        "locations": [
          {
            "line": 3,
            "column": 19
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known argument names/invalid arg name",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment invalidArgName on Dog {\n        doesKnowCommand(unknown: true)\n      }\n    ",
    "errors": [
      {
        "message": "Unknown argument \"unknown\" on field \"doesKnowCommand\" of type \"Dog\".",
        "locations": [
          {
            "line": 3,
            "column": 25
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known argument names/unknown args amongst known args",
    "rule": "KnownArgumentNames",
    "query": "\n      fragment oneGoodArgOneInvalidArg on Dog {\n        doesKnowCommand(whoknows: 1, dogCommand: SIT, unknown: true)\n      }\n    ",
    "errors": [
      {
        "message": "Unknown argument \"whoknows\" on field \"doesKnowCommand\" of type \"Dog\".",
        "locations": [
          {
            "line": 3,
            "column": 25
          }
        ]
      },
      {
        "message": "Unknown argument \"unknown\" on field \"doesKnowCommand\" of type \"Dog\".",
        "locations": [
          {
            "line": 3,
            "column": 55
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known argument names/unknown args deeply",
    "rule": "KnownArgumentNames",
    "query": "\n      {\n        dog {\n          doesKnowCommand(unknown: true)\n        }\n        human {\n          pet {\n            ... on Dog {\n              doesKnowCommand(unknown: true)\n            }\n          }\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Unknown argument \"unknown\" on field \"doesKnowCommand\" of type \"Dog\".",
        "locations": [
          {
            "line": 4,
            "column": 27
          }
        ]
      },
      {
        "message": "Unknown argument \"unknown\" on field \"doesKnowCommand\" of type \"Dog\".",
        "locations": [
          {
            "line": 9,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known directives/with no directives",
    "rule": "KnownDirectives",
    "query": "\n      query Foo {\n        name\n        ...Frag\n      }\n\n      fragment Frag on Dog {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known directives/with known directives",
    "rule": "KnownDirectives",
    "query": "\n      {\n        dog @include(if: true) {\n          name\n        }\n        human @skip(if: false) {\n          name\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known directives/with unknown directive",
    "rule": "KnownDirectives",
    "query": "\n      {\n        dog @unknown(directive: \"value\") {\n          name\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Unknown directive \"unknown\".",
        "locations": [
          {
            "line": 3,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known directives/with many unknown directives",
    "rule": "KnownDirectives",
    "query": "\n      {\n        dog @unknown(directive: \"value\") {\n          name\n        }\n        human @unknown(directive: \"value\") {\n          name\n          pets @unknown(directive: \"value\") {\n            name\n          }\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Unknown directive \"unknown\".",
        "locations": [
          {
            "line": 3,
            "column": 13
          }
        ]
      },
      {
        "message": "Unknown directive \"unknown\".",
        "locations": [
          {
            "line": 6,
            "column": 15
          }
        ]
      },
      {
        "message": "Unknown directive \"unknown\".",
        "locations": [
          {
            "line": 8,
            "column": 16
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known directives/with well placed directives",
    "rule": "KnownDirectives",
    "query": "\n      query Foo @onQuery {\n        name @include(if: true)\n        ...Frag @include(if: true)\n        skippedField @skip(if: true)\n        ...SkippedFrag @skip(if: true)\n      }\n\n      mutation Bar @onMutation {\n        someField\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known directives/with misplaced directives",
    "rule": "KnownDirectives",
    "query": "\n      query Foo @include(if: true) {\n        name @onQuery\n        ...Frag @onQuery\n      }\n\n      mutation Bar @onQuery {\n        someField\n      }\n    ",
    "errors": [
      {
        "message": "Directive \"include\" may not be used on QUERY.",
        "locations": [
          {
            "line": 2,
            "column": 17
          }
        ]
      },
      {
        "message": "Directive \"onQuery\" may not be used on FIELD.",
        "locations": [
          {
            "line": 3,
            "column": 14
          }
        ]
      },
      {
        "message": "Directive \"onQuery\" may not be used on FRAGMENT_SPREAD.",
        "locations": [
          {
            "line": 4,
            "column": 17
          }
        ]
      },
      {
        "message": "Directive \"onQuery\" may not be used on MUTATION.",
        "locations": [
          {
            "line": 7,
            "column": 20
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known fragment names/known fragment names are valid",
    "rule": "KnownFragmentNames",
    "query": "\n      {\n        human(id: 4) {\n          ...HumanFields1\n          ... on Human {\n            ...HumanFields2\n          }\n          ... {\n            name\n          }\n        }\n      }\n      fragment HumanFields1 on Human {\n        name\n        ...HumanFields3\n      }\n      fragment HumanFields2 on Human {\n        name\n      }\n      fragment HumanFields3 on Human {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known fragment names/unknown fragment names are invalid",
    "rule": "KnownFragmentNames",
    "query": "\n      {\n        human(id: 4) {\n          ...UnknownFragment1\n          ... on Human {\n            ...UnknownFragment2\n          }\n        }\n      }\n      fragment HumanFields on Human {\n        name\n        ...UnknownFragment3\n      }\n    ",
    "errors": [
      {
        "message": "Unknown fragment \"UnknownFragment1\".",
        "locations": [
          {
            "line": 4,
            "column": 14
          }
        ]
      },
      {
        "message": "Unknown fragment \"UnknownFragment2\".",
        "locations": [
          {
            "line": 6,
            "column": 16
          }
        ]
      },
      {
        "message": "Unknown fragment \"UnknownFragment3\".",
        "locations": [
          {
            "line": 12,
            "column": 12
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Known type names/known type names are valid",
    "rule": "KnownTypeNames",
    "query": "\n      query Foo($var: String, $required: [String!]!) {\n        user(id: 4) {\n          pets { ... on Pet { name }, ...PetFields, ... { name } }\n        }\n      }\n      fragment PetFields on Pet {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Known type names/unknown type names are invalid",
    "rule": "KnownTypeNames",
    "query": "\n      query Foo($var: JumbledUpLetters) {\n        user(id: 4) {\n          name\n          pets { ... on Badger { name }, ...PetFields }\n        }\n      }\n      fragment PetFields on Peettt {\n        name\n      }\n    ",
    "errors": [
      {
        "message": "Unknown type \"JumbledUpLetters\".",
        "locations": [
          {
            "line": 2,
            "column": 23
          }
        ]
      },
      {
        "message": "Unknown type \"Badger\".",
        "locations": [
          {
            "line": 5,
            "column": 25
          }
        ]
      },
      {
        "message": "Unknown type \"Peettt\".",
        "locations": [
          {
            "line": 8,
            "column": 29
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Anonymous operation must be alone/no operations",
    "rule": "LoneAnonymousOperation",
    "query": "\n      fragment fragA on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Anonymous operation must be alone/one anon operation",
    "rule": "LoneAnonymousOperation",
    "query": "\n      {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Anonymous operation must be alone/multiple named operations",
    "rule": "LoneAnonymousOperation",
    "query": "\n      query Foo {\n        field\n      }\n\n      query Bar {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Anonymous operation must be alone/anon operation with fragment",
    "rule": "LoneAnonymousOperation",
    "query": "\n      {\n        ...Foo\n      }\n      fragment Foo on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Anonymous operation must be alone/multiple anon operations",
    "rule": "LoneAnonymousOperation",
    "query": "\n      {\n        fieldA\n      }\n      {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "This anonymous operation must be the only defined operation.",
        "locations": [
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "This anonymous operation must be the only defined operation.",
        "locations": [
          {
            "line": 5,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Anonymous operation must be alone/anon operation with a mutation",
    "rule": "LoneAnonymousOperation",
    "query": "\n      {\n        fieldA\n      }\n      mutation Foo {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "This anonymous operation must be the only defined operation.",
        "locations": [
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Anonymous operation must be alone/anon operation with a subscription",
    "rule": "LoneAnonymousOperation",
    "query": "\n      {\n        fieldA\n      }\n      subscription Foo {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "This anonymous operation must be the only defined operation.",
        "locations": [
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/single reference is valid",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB }\n      fragment fragB on Dog { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No circular fragment spreads/spreading twice is not circular",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB, ...fragB }\n      fragment fragB on Dog { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No circular fragment spreads/spreading twice indirectly is not circular",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB, ...fragC }\n      fragment fragB on Dog { ...fragC }\n      fragment fragC on Dog { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No circular fragment spreads/double spread within abstract types",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment nameFragment on Pet {\n        ... on Dog { name }\n        ... on Cat { name }\n      }\n\n      fragment spreadsInAnon on Pet {\n        ... on Dog { ...nameFragment }\n        ... on Cat { ...nameFragment }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No circular fragment spreads/does not false positive on unknown fragment",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment nameFragment on Pet {\n        ...UnknownFragment\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No circular fragment spreads/spreading recursively within field fails",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Human { relatives { ...fragA } },\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself.",
        "locations": [
          {
            "line": 2,
            "column": 45
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself directly",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragA }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself.",
        "locations": [
          {
            "line": 2,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself directly within inline fragment",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Pet {\n        ... on Dog {\n          ...fragA\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself.",
        "locations": [
          {
            "line": 4,
            "column": 11
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself indirectly",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB }\n      fragment fragB on Dog { ...fragA }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragB.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 3,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself indirectly reports opposite order",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragB on Dog { ...fragA }\n      fragment fragA on Dog { ...fragB }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragB\" within itself via fragA.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 3,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself indirectly within inline fragment",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Pet {\n        ... on Dog {\n          ...fragB\n        }\n      }\n      fragment fragB on Pet {\n        ... on Dog {\n          ...fragA\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragB.",
        "locations": [
          {
            "line": 4,
            "column": 11
          },
          {
            "line": 9,
            "column": 11
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself deeply",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB }\n      fragment fragB on Dog { ...fragC }\n      fragment fragC on Dog { ...fragO }\n      fragment fragX on Dog { ...fragY }\n      fragment fragY on Dog { ...fragZ }\n      fragment fragZ on Dog { ...fragO }\n      fragment fragO on Dog { ...fragP }\n      fragment fragP on Dog { ...fragA, ...fragX }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragB, fragC, fragO, fragP.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 3,
            "column": 31
          },
          {
            "line": 4,
            "column": 31
          },
          {
            "line": 8,
            "column": 31
          },
          {
            "line": 9,
            "column": 31
          }
        ]
      },
      {
        "message": "Cannot spread fragment \"fragO\" within itself via fragP, fragX, fragY, fragZ.",
        "locations": [
          {
            "line": 8,
            "column": 31
          },
          {
            "line": 9,
            "column": 41
          },
          {
            "line": 5,
            "column": 31
          },
          {
            "line": 6,
            "column": 31
          },
          {
            "line": 7,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself deeply two paths",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB, ...fragC }\n      fragment fragB on Dog { ...fragA }\n      fragment fragC on Dog { ...fragA }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragB.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 3,
            "column": 31
          }
        ]
      },
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragC.",
        "locations": [
          {
            "line": 2,
            "column": 41
          },
          {
            "line": 4,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself deeply two paths -- alt traverse order",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragC }\n      fragment fragB on Dog { ...fragC }\n      fragment fragC on Dog { ...fragA, ...fragB }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragC.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 4,
            "column": 31
          }
        ]
      },
      {
        "message": "Cannot spread fragment \"fragC\" within itself via fragB.",
        "locations": [
          {
            "line": 4,
            "column": 41
          },
          {
            "line": 3,
            "column": 31
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No circular fragment spreads/no spreading itself deeply and immediately",
    "rule": "NoFragmentCycles",
    "query": "\n      fragment fragA on Dog { ...fragB }\n      fragment fragB on Dog { ...fragB, ...fragC }\n      fragment fragC on Dog { ...fragA, ...fragB }\n    ",
    "errors": [
      {
        "message": "Cannot spread fragment \"fragB\" within itself.",
        "locations": [
          {
            "line": 3,
            "column": 31
          }
        ]
      },
      {
        "message": "Cannot spread fragment \"fragA\" within itself via fragB, fragC.",
        "locations": [
          {
            "line": 2,
            "column": 31
          },
          {
            "line": 3,
            "column": 41
          },
          {
            "line": 4,
            "column": 31
          }
        ]
      },
      {
        "message": "Cannot spread fragment \"fragB\" within itself via fragC.",
        "locations": [
          {
            "line": 3,
            "column": 41
          },
          {
            "line": 4,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/all variables defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        field(a: $a, b: $b, c: $c)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/all variables deeply defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        field(a: $a) {\n          field(b: $b) {\n            field(c: $c)\n          }\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/all variables deeply in inline fragments defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ... on Type {\n          field(a: $a) {\n            field(b: $b) {\n              ... on Type {\n                field(c: $c)\n              }\n            }\n          }\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/all variables in fragments deeply defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field(c: $c)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/variable within single fragment defined in multiple operations",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragA\n      }\n      query Bar($a: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/variable within fragments defined in operations",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragA\n      }\n      query Bar($b: String) {\n        ...FragB\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n      fragment FragB on Type {\n        field(b: $b)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/variable within recursive fragment defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragA\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No undefined variables/variable not defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        field(a: $a, b: $b, c: $c, d: $d)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$d\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 3,
            "column": 39
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/variable not defined by un-named query",
    "rule": "NoUndefinedVariables",
    "query": "\n      {\n        field(a: $a)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined.",
        "locations": [
          {
            "line": 3,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/multiple variables not defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($b: String) {\n        field(a: $a, b: $b, c: $c)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 3,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$c\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 3,
            "column": 32
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/variable in fragment not defined by un-named query",
    "rule": "NoUndefinedVariables",
    "query": "\n      {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined.",
        "locations": [
          {
            "line": 6,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/variable in fragment not defined by operation",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String, $b: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field(c: $c)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$c\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 16,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/multiple variables in fragments not defined",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field(c: $c)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 6,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$c\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 16,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/single variable in fragment not defined by multiple operations",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragAB\n      }\n      query Bar($a: String) {\n        ...FragAB\n      }\n      fragment FragAB on Type {\n        field(a: $a, b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$b\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 9,
            "column": 25
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$b\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 9,
            "column": 25
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/variables in fragment not defined by multiple operations",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragAB\n      }\n      query Bar($a: String) {\n        ...FragAB\n      }\n      fragment FragAB on Type {\n        field(a: $a, b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 9,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$b\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 9,
            "column": 25
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/variable in fragment used by other operation",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragA\n      }\n      query Bar($a: String) {\n        ...FragB\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n      fragment FragB on Type {\n        field(b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 9,
            "column": 18
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$b\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 12,
            "column": 18
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No undefined variables/multiple undefined variables produce multiple errors",
    "rule": "NoUndefinedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragAB\n      }\n      query Bar($a: String) {\n        ...FragAB\n      }\n      fragment FragAB on Type {\n        field1(a: $a, b: $b)\n        ...FragC\n        field3(a: $a, b: $b)\n      }\n      fragment FragC on Type {\n        field2(c: $c)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 9,
            "column": 19
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$a\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 11,
            "column": 19
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$c\" is not defined by operation \"Foo\".",
        "locations": [
          {
            "line": 14,
            "column": 19
          },
          {
            "line": 2,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$b\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 9,
            "column": 26
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$b\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 11,
            "column": 26
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      },
      {
        "message": "Variable \"$c\" is not defined by operation \"Bar\".",
        "locations": [
          {
            "line": 14,
            "column": 19
          },
          {
            "line": 5,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused fragments/all fragment names are used",
    "rule": "NoUnusedFragments",
    "query": "\n      {\n        human(id: 4) {\n          ...HumanFields1\n          ... on Human {\n            ...HumanFields2\n          }\n        }\n      }\n      fragment HumanFields1 on Human {\n        name\n        ...HumanFields3\n      }\n      fragment HumanFields2 on Human {\n        name\n      }\n      fragment HumanFields3 on Human {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused fragments/all fragment names are used by multiple operations",
    "rule": "NoUnusedFragments",
    "query": "\n      query Foo {\n        human(id: 4) {\n          ...HumanFields1\n        }\n      }\n      query Bar {\n        human(id: 4) {\n          ...HumanFields2\n        }\n      }\n      fragment HumanFields1 on Human {\n        name\n        ...HumanFields3\n      }\n      fragment HumanFields2 on Human {\n        name\n      }\n      fragment HumanFields3 on Human {\n        name\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused fragments/contains unknown fragments",
    "rule": "NoUnusedFragments",
    "query": "\n      query Foo {\n        human(id: 4) {\n          ...HumanFields1\n        }\n      }\n      query Bar {\n        human(id: 4) {\n          ...HumanFields2\n        }\n      }\n      fragment HumanFields1 on Human {\n        name\n        ...HumanFields3\n      }\n      fragment HumanFields2 on Human {\n        name\n      }\n      fragment HumanFields3 on Human {\n        name\n      }\n      fragment Unused1 on Human {\n        name\n      }\n      fragment Unused2 on Human {\n        name\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"Unused1\" is never used.",
        "locations": [
          {
            "line": 22,
            "column": 7
          }
        ]
      },
      {
        "message": "Fragment \"Unused2\" is never used.",
        "locations": [
          {
            "line": 25,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused fragments/contains unknown fragments with ref cycle",
    "rule": "NoUnusedFragments",
    "query": "\n      query Foo {\n        human(id: 4) {\n          ...HumanFields1\n        }\n      }\n      query Bar {\n        human(id: 4) {\n          ...HumanFields2\n        }\n      }\n      fragment HumanFields1 on Human {\n        name\n        ...HumanFields3\n      }\n      fragment HumanFields2 on Human {\n        name\n      }\n      fragment HumanFields3 on Human {\n        name\n      }\n      fragment Unused1 on Human {\n        name\n        ...Unused2\n      }\n      fragment Unused2 on Human {\n        name\n        ...Unused1\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"Unused1\" is never used.",
        "locations": [
          {
            "line": 22,
            "column": 7
          }
        ]
      },
      {
        "message": "Fragment \"Unused2\" is never used.",
        "locations": [
          {
            "line": 26,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused fragments/contains unknown and undef fragments",
    "rule": "NoUnusedFragments",
    "query": "\n      query Foo {\n        human(id: 4) {\n          ...bar\n        }\n      }\n      fragment foo on Human {\n        name\n      }\n    ",
    "errors": [
      {
        "message": "Fragment \"foo\" is never used.",
        "locations": [
          {
            "line": 7,
            "column": 7
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/uses all variables",
    "rule": "NoUnusedVariables",
    "query": "\n      query ($a: String, $b: String, $c: String) {\n        field(a: $a, b: $b, c: $c)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/uses all variables deeply",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        field(a: $a) {\n          field(b: $b) {\n            field(c: $c)\n          }\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/uses all variables deeply in inline fragments",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ... on Type {\n          field(a: $a) {\n            field(b: $b) {\n              ... on Type {\n                field(c: $c)\n              }\n            }\n          }\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/uses all variables in fragments",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field(c: $c)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/variable used by fragment in multiple operations",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragA\n      }\n      query Bar($b: String) {\n        ...FragB\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n      fragment FragB on Type {\n        field(b: $b)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/variable used by recursive fragment",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragA\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: No unused variables/variable not used",
    "rule": "NoUnusedVariables",
    "query": "\n      query ($a: String, $b: String, $c: String) {\n        field(a: $a, b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$c\" is never used.",
        "locations": [
          {
            "line": 2,
            "column": 38
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/multiple variables not used",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        field(b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 17
          }
        ]
      },
      {
        "message": "Variable \"$c\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/variable not used in fragments",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a) {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$c\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/multiple variables not used in fragments",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($a: String, $b: String, $c: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field {\n          ...FragB\n        }\n      }\n      fragment FragB on Type {\n        field(b: $b) {\n          ...FragC\n        }\n      }\n      fragment FragC on Type {\n        field\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$a\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 17
          }
        ]
      },
      {
        "message": "Variable \"$c\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/variable not used by unreferenced fragment",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragA\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n      fragment FragB on Type {\n        field(b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$b\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 17
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: No unused variables/variable not used by fragment used by other operation",
    "rule": "NoUnusedVariables",
    "query": "\n      query Foo($b: String) {\n        ...FragA\n      }\n      query Bar($a: String) {\n        ...FragB\n      }\n      fragment FragA on Type {\n        field(a: $a)\n      }\n      fragment FragB on Type {\n        field(b: $b)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$b\" is never used in operation \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 17
          }
        ]
      },
      {
        "message": "Variable \"$a\" is never used in operation \"Bar\".",
        "locations": [
          {
            "line": 5,
            "column": 17
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/of the same object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment objectWithinObject on Dog { ...dogFragment }\n      fragment dogFragment on Dog { barkVolume }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/of the same object with inline fragment",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment objectWithinObjectAnon on Dog { ... on Dog { barkVolume } }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/object into an implemented interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment objectWithinInterface on Pet { ...dogFragment }\n      fragment dogFragment on Dog { barkVolume }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/object into containing union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment objectWithinUnion on CatOrDog { ...dogFragment }\n      fragment dogFragment on Dog { barkVolume }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/union into contained object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment unionWithinObject on Dog { ...catOrDogFragment }\n      fragment catOrDogFragment on CatOrDog { __typename }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/union into overlapping interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment unionWithinInterface on Pet { ...catOrDogFragment }\n      fragment catOrDogFragment on CatOrDog { __typename }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/union into overlapping union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment unionWithinUnion on DogOrHuman { ...catOrDogFragment }\n      fragment catOrDogFragment on CatOrDog { __typename }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/interface into implemented object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment interfaceWithinObject on Dog { ...petFragment }\n      fragment petFragment on Pet { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/interface into overlapping interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment interfaceWithinInterface on Pet { ...beingFragment }\n      fragment beingFragment on Being { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/interface into overlapping interface in inline fragment",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment interfaceWithinInterface on Pet { ... on Being { name } }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/interface into overlapping union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment interfaceWithinUnion on CatOrDog { ...petFragment }\n      fragment petFragment on Pet { name }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Possible fragment spreads/different object into object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidObjectWithinObject on Cat { ...dogFragment }\n      fragment dogFragment on Dog { barkVolume }\n    ",
    "errors": [
      {
        "message": "Fragment \"dogFragment\" cannot be spread here as objects of type \"Cat\" can never be of type \"Dog\".",
        "locations": [
          {
            "line": 2,
            "column": 51
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/different object into object in inline fragment",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidObjectWithinObjectAnon on Cat {\n        ... on Dog { barkVolume }\n      }\n    ",
    "errors": [
      {
        "message": "Fragment cannot be spread here as objects of type \"Cat\" can never be of type \"Dog\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/object into not implementing interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidObjectWithinInterface on Pet { ...humanFragment }\n      fragment humanFragment on Human { pets { name } }\n    ",
    "errors": [
      {
        "message": "Fragment \"humanFragment\" cannot be spread here as objects of type \"Pet\" can never be of type \"Human\".",
        "locations": [
          {
            "line": 2,
            "column": 54
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/object into not containing union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidObjectWithinUnion on CatOrDog { ...humanFragment }\n      fragment humanFragment on Human { pets { name } }\n    ",
    "errors": [
      {
        "message": "Fragment \"humanFragment\" cannot be spread here as objects of type \"CatOrDog\" can never be of type \"Human\".",
        "locations": [
          {
            "line": 2,
            "column": 55
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/union into not contained object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidUnionWithinObject on Human { ...catOrDogFragment }\n      fragment catOrDogFragment on CatOrDog { __typename }\n    ",
    "errors": [
      {
        "message": "Fragment \"catOrDogFragment\" cannot be spread here as objects of type \"Human\" can never be of type \"CatOrDog\".",
        "locations": [
          {
            "line": 2,
            "column": 52
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/union into non overlapping interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidUnionWithinInterface on Pet { ...humanOrAlienFragment }\n      fragment humanOrAlienFragment on HumanOrAlien { __typename }\n    ",
    "errors": [
      {
        "message": "Fragment \"humanOrAlienFragment\" cannot be spread here as objects of type \"Pet\" can never be of type \"HumanOrAlien\".",
        "locations": [
          {
            "line": 2,
            "column": 53
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/union into non overlapping union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidUnionWithinUnion on CatOrDog { ...humanOrAlienFragment }\n      fragment humanOrAlienFragment on HumanOrAlien { __typename }\n    ",
    "errors": [
      {
        "message": "Fragment \"humanOrAlienFragment\" cannot be spread here as objects of type \"CatOrDog\" can never be of type \"HumanOrAlien\".",
        "locations": [
          {
            "line": 2,
            "column": 54
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/interface into non implementing object",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidInterfaceWithinObject on Cat { ...intelligentFragment }\n      fragment intelligentFragment on Intelligent { iq }\n    ",
    "errors": [
      {
        "message": "Fragment \"intelligentFragment\" cannot be spread here as objects of type \"Cat\" can never be of type \"Intelligent\".",
        "locations": [
          {
            "line": 2,
            "column": 54
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/interface into non overlapping interface",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidInterfaceWithinInterface on Pet {\n        ...intelligentFragment\n      }\n      fragment intelligentFragment on Intelligent { iq }\n    ",
    "errors": [
      {
        "message": "Fragment \"intelligentFragment\" cannot be spread here as objects of type \"Pet\" can never be of type \"Intelligent\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/interface into non overlapping interface in inline fragment",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidInterfaceWithinInterfaceAnon on Pet {\n        ...on Intelligent { iq }\n      }\n    ",
    "errors": [
      {
        "message": "Fragment cannot be spread here as objects of type \"Pet\" can never be of type \"Intelligent\".",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Possible fragment spreads/interface into non overlapping union",
    "rule": "PossibleFragmentSpreads",
    "query": "\n      fragment invalidInterfaceWithinUnion on HumanOrAlien { ...petFragment }\n      fragment petFragment on Pet { name }\n    ",
    "errors": [
      {
        "message": "Fragment \"petFragment\" cannot be spread here as objects of type \"HumanOrAlien\" can never be of type \"Pet\".",
        "locations": [
          {
            "line": 2,
            "column": 62
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Provided required arguments/ignores unknown arguments",
    "rule": "ProvidedNonNullArguments",
    "query": "\n      {\n        dog {\n          isHousetrained(unknownArgument: true)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Arg on optional arg",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          dog {\n            isHousetrained(atOtherHomes: true)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/No Arg on optional arg",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          dog {\n            isHousetrained\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Multiple args",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req1: 1, req2: 2)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Multiple args reverse order",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req2: 2, req1: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/No args on multiple optional",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/One arg on multiple optional",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts(opt1: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Second arg on multiple optional",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOpts(opt2: 1)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Multiple reqs on mixedList",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/Multiple reqs and one opt on mixedList",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4, opt1: 5)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Valid non-nullable value/All reqs and opts on mixedList",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleOptAndReq(req1: 3, req2: 4, opt1: 5, opt2: 6)\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Invalid non-nullable value/Missing one non-nullable argument",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req2: 2)\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Field \"multipleReqs\" argument \"req1\" of type \"Int!\" is required but not provided.",
        "locations": [
          {
            "line": 4,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Provided required arguments/Invalid non-nullable value/Missing multiple non-nullable arguments",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Field \"multipleReqs\" argument \"req1\" of type \"Int!\" is required but not provided.",
        "locations": [
          {
            "line": 4,
            "column": 13
          }
        ]
      },
      {
        "message": "Field \"multipleReqs\" argument \"req2\" of type \"Int!\" is required but not provided.",
        "locations": [
          {
            "line": 4,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Provided required arguments/Invalid non-nullable value/Incorrect value and missing argument",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          complicatedArgs {\n            multipleReqs(req1: \"one\")\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Field \"multipleReqs\" argument \"req2\" of type \"Int!\" is required but not provided.",
        "locations": [
          {
            "line": 4,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Provided required arguments/Directive arguments/ignores unknown directives",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          dog @unknown\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Directive arguments/with directives of valid types",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          dog @include(if: true) {\n            name\n          }\n          human @skip(if: false) {\n            name\n          }\n        }\n      ",
    "errors": []
  },
  {
    "name": "Validate: Provided required arguments/Directive arguments/with directive with missing types",
    "rule": "ProvidedNonNullArguments",
    "query": "\n        {\n          dog @include {\n            name @skip\n          }\n        }\n      ",
    "errors": [
      {
        "message": "Directive \"@include\" argument \"if\" of type \"Boolean!\" is required but not provided.",
        "locations": [
          {
            "line": 3,
            "column": 15
          }
        ]
      },
      {
        "message": "Directive \"@skip\" argument \"if\" of type \"Boolean!\" is required but not provided.",
        "locations": [
          {
            "line": 4,
            "column": 18
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/valid scalar selection",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelection on Dog {\n        barks\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Scalar leafs/object type missing selection",
    "rule": "ScalarLeafs",
    "query": "\n      query directQueryOnObjectWithoutSubFields {\n        human\n      }\n    ",
    "errors": [
      {
        "message": "Field \"human\" of type \"Human\" must have a selection of subfields. Did you mean \"human { ... }\"?",
        "locations": [
          {
            "line": 3,
            "column": 9
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/interface type missing selection",
    "rule": "ScalarLeafs",
    "query": "\n      {\n        human { pets }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"pets\" of type \"[Pet]\" must have a selection of subfields. Did you mean \"pets { ... }\"?",
        "locations": [
          {
            "line": 3,
            "column": 17
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/valid scalar selection with args",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionWithArgs on Dog {\n        doesKnowCommand(dogCommand: SIT)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Scalar leafs/scalar selection not allowed on Boolean",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionsNotAllowedOnBoolean on Dog {\n        barks { sinceWhen }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"barks\" must not have a selection since type \"Boolean\" has no subfields.",
        "locations": [
          {
            "line": 3,
            "column": 15
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/scalar selection not allowed on Enum",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionsNotAllowedOnEnum on Cat {\n        furColor { inHexdec }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"furColor\" must not have a selection since type \"FurColor\" has no subfields.",
        "locations": [
          {
            "line": 3,
            "column": 18
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/scalar selection not allowed with args",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionsNotAllowedWithArgs on Dog {\n        doesKnowCommand(dogCommand: SIT) { sinceWhen }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"doesKnowCommand\" must not have a selection since type \"Boolean\" has no subfields.",
        "locations": [
          {
            "line": 3,
            "column": 42
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/Scalar selection not allowed with directives",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionsNotAllowedWithDirectives on Dog {\n        name @include(if: true) { isAlsoHumanName }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"name\" must not have a selection since type \"String\" has no subfields.",
        "locations": [
          {
            "line": 3,
            "column": 33
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Scalar leafs/Scalar selection not allowed with directives and args",
    "rule": "ScalarLeafs",
    "query": "\n      fragment scalarSelectionsNotAllowedWithDirectivesAndArgs on Dog {\n        doesKnowCommand(dogCommand: SIT) @include(if: true) { sinceWhen }\n      }\n    ",
    "errors": [
      {
        "message": "Field \"doesKnowCommand\" must not have a selection since type \"Boolean\" has no subfields.",
        "locations": [
          {
            "line": 3,
            "column": 61
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique argument names/no arguments on field",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/no arguments on directive",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/argument on field",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field(arg: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/argument on directive",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive(arg: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/same argument on two fields",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        one: field(arg: \"value\")\n        two: field(arg: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/same argument on field and directive",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field(arg: \"value\") @directive(arg: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/same argument on two directives",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive1(arg: \"value\") @directive2(arg: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/multiple field arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field(arg1: \"value\", arg2: \"value\", arg3: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/multiple directive arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive(arg1: \"value\", arg2: \"value\", arg3: \"value\")\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique argument names/duplicate field arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field(arg1: \"value\", arg1: \"value\")\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 30
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique argument names/many duplicate field arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field(arg1: \"value\", arg1: \"value\", arg1: \"value\")\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 30
          }
        ]
      },
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 45
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique argument names/duplicate directive arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive(arg1: \"value\", arg1: \"value\")\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 26
          },
          {
            "line": 3,
            "column": 41
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique argument names/many duplicate directive arguments",
    "rule": "UniqueArgumentNames",
    "query": "\n      {\n        field @directive(arg1: \"value\", arg1: \"value\", arg1: \"value\")\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 26
          },
          {
            "line": 3,
            "column": 41
          }
        ]
      },
      {
        "message": "There can be only one argument named \"arg1\".",
        "locations": [
          {
            "line": 3,
            "column": 26
          },
          {
            "line": 3,
            "column": 56
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Directives Are Unique Per Location/no directives",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Directives Are Unique Per Location/unique directives in different locations",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type @directiveA {\n        field @directiveB\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Directives Are Unique Per Location/unique directives in same locations",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type @directiveA @directiveB {\n        field @directiveA @directiveB\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Directives Are Unique Per Location/same directives in different locations",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type @directiveA {\n        field @directiveA\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Directives Are Unique Per Location/same directives in similar locations",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type {\n        field @directive\n        field @directive\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Directives Are Unique Per Location/duplicate directives in one location",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type {\n        field @directive @directive\n      }\n    ",
    "errors": [
      {
        "message": "The directive \"directive\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 26
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Directives Are Unique Per Location/many duplicate directives in one location",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type {\n        field @directive @directive @directive\n      }\n    ",
    "errors": [
      {
        "message": "The directive \"directive\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 26
          }
        ]
      },
      {
        "message": "The directive \"directive\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 37
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Directives Are Unique Per Location/different duplicate directives in one location",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type {\n        field @directiveA @directiveB @directiveA @directiveB\n      }\n    ",
    "errors": [
      {
        "message": "The directive \"directiveA\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 39
          }
        ]
      },
      {
        "message": "The directive \"directiveB\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 27
          },
          {
            "line": 3,
            "column": 51
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Directives Are Unique Per Location/duplicate directives in many locations",
    "rule": "UniqueDirectivesPerLocation",
    "query": "\n      fragment Test on Type @directive @directive {\n        field @directive @directive\n      }\n    ",
    "errors": [
      {
        "message": "The directive \"directive\" can only be used once at this location.",
        "locations": [
          {
            "line": 2,
            "column": 29
          },
          {
            "line": 2,
            "column": 40
          }
        ]
      },
      {
        "message": "The directive \"directive\" can only be used once at this location.",
        "locations": [
          {
            "line": 3,
            "column": 15
          },
          {
            "line": 3,
            "column": 26
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique fragment names/no fragments",
    "rule": "UniqueFragmentNames",
    "query": "\n      {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique fragment names/one fragment",
    "rule": "UniqueFragmentNames",
    "query": "\n      {\n        ...fragA\n      }\n\n      fragment fragA on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique fragment names/many fragments",
    "rule": "UniqueFragmentNames",
    "query": "\n      {\n        ...fragA\n        ...fragB\n        ...fragC\n      }\n      fragment fragA on Type {\n        fieldA\n      }\n      fragment fragB on Type {\n        fieldB\n      }\n      fragment fragC on Type {\n        fieldC\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique fragment names/inline fragments are always unique",
    "rule": "UniqueFragmentNames",
    "query": "\n      {\n        ...on Type {\n          fieldA\n        }\n        ...on Type {\n          fieldB\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique fragment names/fragment and operation named the same",
    "rule": "UniqueFragmentNames",
    "query": "\n      query Foo {\n        ...Foo\n      }\n      fragment Foo on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique fragment names/fragments named the same",
    "rule": "UniqueFragmentNames",
    "query": "\n      {\n        ...fragA\n      }\n      fragment fragA on Type {\n        fieldA\n      }\n      fragment fragA on Type {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one fragment named \"fragA\".",
        "locations": [
          {
            "line": 5,
            "column": 16
          },
          {
            "line": 8,
            "column": 16
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique fragment names/fragments named the same without being referenced",
    "rule": "UniqueFragmentNames",
    "query": "\n      fragment fragA on Type {\n        fieldA\n      }\n      fragment fragA on Type {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one fragment named \"fragA\".",
        "locations": [
          {
            "line": 2,
            "column": 16
          },
          {
            "line": 5,
            "column": 16
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique input field names/input object with fields",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg: { f: true })\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique input field names/same input object within two args",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg1: { f: true }, arg2: { f: true })\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique input field names/multiple input object fields",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg: { f1: \"value\", f2: \"value\", f3: \"value\" })\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique input field names/allows for nested input objects with similar fields",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg: {\n          deep: {\n            deep: {\n              id: 1\n            }\n            id: 1\n          }\n          id: 1\n        })\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique input field names/duplicate input object fields",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg: { f1: \"value\", f1: \"value\" })\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one input field named \"f1\".",
        "locations": [
          {
            "line": 3,
            "column": 22
          },
          {
            "line": 3,
            "column": 35
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique input field names/many duplicate input object fields",
    "rule": "UniqueInputFieldNames",
    "query": "\n      {\n        field(arg: { f1: \"value\", f1: \"value\", f1: \"value\" })\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one input field named \"f1\".",
        "locations": [
          {
            "line": 3,
            "column": 22
          },
          {
            "line": 3,
            "column": 35
          }
        ]
      },
      {
        "message": "There can be only one input field named \"f1\".",
        "locations": [
          {
            "line": 3,
            "column": 22
          },
          {
            "line": 3,
            "column": 48
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique operation names/no operations",
    "rule": "UniqueOperationNames",
    "query": "\n      fragment fragA on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/one anon operation",
    "rule": "UniqueOperationNames",
    "query": "\n      {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/one named operation",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/multiple operations",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        field\n      }\n\n      query Bar {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/multiple operations of different types",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        field\n      }\n\n      mutation Bar {\n        field\n      }\n\n      subscription Baz {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/fragment and operation named the same",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        ...Foo\n      }\n      fragment Foo on Type {\n        field\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique operation names/multiple operations of same name",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        fieldA\n      }\n      query Foo {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one operation named \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 13
          },
          {
            "line": 5,
            "column": 13
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique operation names/multiple ops of same name of different types (mutation)",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        fieldA\n      }\n      mutation Foo {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one operation named \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 13
          },
          {
            "line": 5,
            "column": 16
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique operation names/multiple ops of same name of different types (subscription)",
    "rule": "UniqueOperationNames",
    "query": "\n      query Foo {\n        fieldA\n      }\n      subscription Foo {\n        fieldB\n      }\n    ",
    "errors": [
      {
        "message": "There can be only one operation named \"Foo\".",
        "locations": [
          {
            "line": 2,
            "column": 13
          },
          {
            "line": 5,
            "column": 20
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Unique variable names/unique variable names",
    "rule": "UniqueVariableNames",
    "query": "\n      query A($x: Int, $y: String) { __typename }\n      query B($x: String, $y: Int) { __typename }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Unique variable names/duplicate variable names",
    "rule": "UniqueVariableNames",
    "query": "\n      query A($x: Int, $x: Int, $x: String) { __typename }\n      query B($x: String, $x: Int) { __typename }\n      query C($x: Int, $x: Int) { __typename }\n    ",
    "errors": [
      {
        "message": "There can be only one variable named \"x\".",
        "locations": [
          {
            "line": 2,
            "column": 16
          },
          {
            "line": 2,
            "column": 25
          }
        ]
      },
      {
        "message": "There can be only one variable named \"x\".",
        "locations": [
          {
            "line": 2,
            "column": 16
          },
          {
            "line": 2,
            "column": 34
          }
        ]
      },
      {
        "message": "There can be only one variable named \"x\".",
        "locations": [
          {
            "line": 3,
            "column": 16
          },
          {
            "line": 3,
            "column": 28
          }
        ]
      },
      {
        "message": "There can be only one variable named \"x\".",
        "locations": [
          {
            "line": 4,
            "column": 16
          },
          {
            "line": 4,
            "column": 25
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are input types/input types are valid",
    "rule": "VariablesAreInputTypes",
    "query": "\n      query Foo($a: String, $b: [Boolean!]!, $c: ComplexInput) {\n        field(a: $a, b: $b, c: $c)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are input types/output types are invalid",
    "rule": "VariablesAreInputTypes",
    "query": "\n      query Foo($a: Dog, $b: [[CatOrDog!]]!, $c: Pet) {\n        field(a: $a, b: $b, c: $c)\n      }\n    ",
    "errors": [
      {
        "locations": [
          {
            "line": 2,
            "column": 21
          }
        ],
        "message": "Variable \"$a\" cannot be non-input type \"Dog\"."
      },
      {
        "locations": [
          {
            "line": 2,
            "column": 30
          }
        ],
        "message": "Variable \"$b\" cannot be non-input type \"[[CatOrDog!]]!\"."
      },
      {
        "locations": [
          {
            "line": 2,
            "column": 50
          }
        ],
        "message": "Variable \"$c\" cannot be non-input type \"Pet\"."
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean => Boolean",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($booleanArg: Boolean)\n      {\n        complicatedArgs {\n          booleanArgField(booleanArg: $booleanArg)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean => Boolean within fragment",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      fragment booleanArgFrag on ComplicatedArgs {\n        booleanArgField(booleanArg: $booleanArg)\n      }\n      query Query($booleanArg: Boolean)\n      {\n        complicatedArgs {\n          ...booleanArgFrag\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean => Boolean within fragment",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($booleanArg: Boolean)\n      {\n        complicatedArgs {\n          ...booleanArgFrag\n        }\n      }\n      fragment booleanArgFrag on ComplicatedArgs {\n        booleanArgField(booleanArg: $booleanArg)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean! => Boolean",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($nonNullBooleanArg: Boolean!)\n      {\n        complicatedArgs {\n          booleanArgField(booleanArg: $nonNullBooleanArg)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean! => Boolean within fragment",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      fragment booleanArgFrag on ComplicatedArgs {\n        booleanArgField(booleanArg: $nonNullBooleanArg)\n      }\n\n      query Query($nonNullBooleanArg: Boolean!)\n      {\n        complicatedArgs {\n          ...booleanArgFrag\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Int => Int! with default",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($intArg: Int = 1)\n      {\n        complicatedArgs {\n          nonNullIntArgField(nonNullIntArg: $intArg)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/[String] => [String]",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringListVar: [String])\n      {\n        complicatedArgs {\n          stringListArgField(stringListArg: $stringListVar)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/[String!] => [String]",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringListVar: [String!])\n      {\n        complicatedArgs {\n          stringListArgField(stringListArg: $stringListVar)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/String => [String] in item position",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringVar: String)\n      {\n        complicatedArgs {\n          stringListArgField(stringListArg: [$stringVar])\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/String! => [String] in item position",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringVar: String!)\n      {\n        complicatedArgs {\n          stringListArgField(stringListArg: [$stringVar])\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/ComplexInput => ComplexInput",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($complexVar: ComplexInput)\n      {\n        complicatedArgs {\n          complexArgField(complexArg: $complexVar)\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/ComplexInput => ComplexInput in field position",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($boolVar: Boolean = false)\n      {\n        complicatedArgs {\n          complexArgField(complexArg: {requiredArg: $boolVar})\n        }\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean! => Boolean! in directive",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($boolVar: Boolean!)\n      {\n        dog @include(if: $boolVar)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean => Boolean! in directive with default",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($boolVar: Boolean = false)\n      {\n        dog @include(if: $boolVar)\n      }\n    ",
    "errors": []
  },
  {
    "name": "Validate: Variables are in allowed positions/Int => Int!",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($intArg: Int) {\n        complicatedArgs {\n          nonNullIntArgField(nonNullIntArg: $intArg)\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$intArg\" of type \"Int\" used in position expecting type \"Int!\".",
        "locations": [
          {
            "line": 2,
            "column": 19
          },
          {
            "line": 4,
            "column": 45
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/Int => Int! within fragment",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      fragment nonNullIntArgFieldFrag on ComplicatedArgs {\n        nonNullIntArgField(nonNullIntArg: $intArg)\n      }\n\n      query Query($intArg: Int) {\n        complicatedArgs {\n          ...nonNullIntArgFieldFrag\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$intArg\" of type \"Int\" used in position expecting type \"Int!\".",
        "locations": [
          {
            "line": 6,
            "column": 19
          },
          {
            "line": 3,
            "column": 43
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/Int => Int! within nested fragment",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      fragment outerFrag on ComplicatedArgs {\n        ...nonNullIntArgFieldFrag\n      }\n\n      fragment nonNullIntArgFieldFrag on ComplicatedArgs {\n        nonNullIntArgField(nonNullIntArg: $intArg)\n      }\n\n      query Query($intArg: Int) {\n        complicatedArgs {\n          ...outerFrag\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$intArg\" of type \"Int\" used in position expecting type \"Int!\".",
        "locations": [
          {
            "line": 10,
            "column": 19
          },
          {
            "line": 7,
            "column": 43
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/String over Boolean",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringVar: String) {\n        complicatedArgs {\n          booleanArgField(booleanArg: $stringVar)\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$stringVar\" of type \"String\" used in position expecting type \"Boolean\".",
        "locations": [
          {
            "line": 2,
            "column": 19
          },
          {
            "line": 4,
            "column": 39
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/String => [String]",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringVar: String) {\n        complicatedArgs {\n          stringListArgField(stringListArg: $stringVar)\n        }\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$stringVar\" of type \"String\" used in position expecting type \"[String]\".",
        "locations": [
          {
            "line": 2,
            "column": 19
          },
          {
            "line": 4,
            "column": 45
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/Boolean => Boolean! in directive",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($boolVar: Boolean) {\n        dog @include(if: $boolVar)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$boolVar\" of type \"Boolean\" used in position expecting type \"Boolean!\".",
        "locations": [
          {
            "line": 2,
            "column": 19
          },
          {
            "line": 3,
            "column": 26
          }
        ]
      }
    ]
  },
  {
    "name": "Validate: Variables are in allowed positions/String => Boolean! in directive",
    "rule": "VariablesInAllowedPosition",
    "query": "\n      query Query($stringVar: String) {\n        dog @include(if: $stringVar)\n      }\n    ",
    "errors": [
      {
        "message": "Variable \"$stringVar\" of type \"String\" used in position expecting type \"Boolean!\".",
        "locations": [
          {
            "line": 2,
            "column": 19
          },
          {
            "line": 3,
            "column": 26
          }
        ]
      }
    ]
  }
]