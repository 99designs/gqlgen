// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package subdir

import (
	"bytes"
	"context"
	"embed"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{SchemaData: cfg.Schema, Resolvers: cfg.Resolvers, Directives: cfg.Directives, ComplexityRoot: cfg.Complexity}
}

type Config = graphql.Config[ResolverRoot, DirectiveRoot, ComplexityRoot]

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Query struct {
		InSchemadir        func(childComplexity int) int
		Parentdir          func(childComplexity int) int
		Subdir             func(childComplexity int) int
		__resolve__service func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type executableSchema graphql.ExecutableSchemaState[ResolverRoot, DirectiveRoot, ComplexityRoot]

func (e *executableSchema) Schema() *ast.Schema {
	if e.SchemaData != nil {
		return e.SchemaData
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := newExecutionContext(nil, e, nil)
	_ = ec
	switch typeName + "." + field {

	case "Query.inSchemadir":
		if e.ComplexityRoot.Query.InSchemadir == nil {
			break
		}

		return e.ComplexityRoot.Query.InSchemadir(childComplexity), true

	case "Query.parentdir":
		if e.ComplexityRoot.Query.Parentdir == nil {
			break
		}

		return e.ComplexityRoot.Query.Parentdir(childComplexity), true

	case "Query.subdir":
		if e.ComplexityRoot.Query.Subdir == nil {
			break
		}

		return e.ComplexityRoot.Query.Subdir(childComplexity), true

	case "Query._service":
		if e.ComplexityRoot.Query.__resolve__service == nil {
			break
		}

		return e.ComplexityRoot.Query.__resolve__service(childComplexity), true

	case "_Service.sdl":
		if e.ComplexityRoot._Service.SDL == nil {
			break
		}

		return e.ComplexityRoot._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := newExecutionContext(opCtx, e, make(chan graphql.DeferredResult))
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.PendingDeferred) > 0 {
					result := <-ec.DeferredResults
					atomic.AddInt32(&ec.PendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.Deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.PendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.ExecutionContextState[ResolverRoot, DirectiveRoot, ComplexityRoot]
}

func newExecutionContext(
	opCtx *graphql.OperationContext,
	execSchema *executableSchema,
	deferredResults chan graphql.DeferredResult,
) executionContext {
	return executionContext{
		ExecutionContextState: graphql.NewExecutionContextState[ResolverRoot, DirectiveRoot, ComplexityRoot](
			opCtx,
			(*graphql.ExecutableSchemaState[ResolverRoot, DirectiveRoot, ComplexityRoot])(execSchema),
			parsedSchema,
			deferredResults,
		),
	}
}

//go:embed "schemadir/root.graphqls" "subdir.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schemadir/root.graphqls", Input: sourceData("schemadir/root.graphqls"), BuiltIn: false},
	{Name: "../parent.graphqls", Input: `extend type Query {
    parentdir: String!
}
`, BuiltIn: false},
	{Name: "subdir.graphqls", Input: sourceData("subdir.graphqls"), BuiltIn: false},
	{Name: "federation/directives.graphql", Input: `
	directive @key(fields: _FieldSet!) repeatable on OBJECT | INTERFACE
	directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
	directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
	directive @extends on OBJECT | INTERFACE
	directive @external on FIELD_DEFINITION
	scalar _Any
	scalar _FieldSet
`, BuiltIn: true},
	{Name: "federation/entity.graphql", Input: `
type _Service {
  sdl: String
}

extend type Query {
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
