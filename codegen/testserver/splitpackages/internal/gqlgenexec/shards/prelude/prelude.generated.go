// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package prelude

import (
	"context"
	"fmt"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/executor/shardruntime"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser/v2/ast"
)

const splitScope = "github.com/99designs/gqlgen/codegen/testserver/splitpackages"

func init() {
	shardruntime.RegisterObject(splitScope, "__Directive", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.Directive)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Directive", obj))
		}
		return ___Directive(ctx, ec, sel, typedObj)
	})
	shardruntime.RegisterObject(splitScope, "__EnumValue", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.EnumValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __EnumValue", obj))
		}
		return ___EnumValue(ctx, ec, sel, typedObj)
	})
	shardruntime.RegisterObject(splitScope, "__Field", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.Field)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Field", obj))
		}
		return ___Field(ctx, ec, sel, typedObj)
	})
	shardruntime.RegisterObject(splitScope, "__InputValue", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.InputValue)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __InputValue", obj))
		}
		return ___InputValue(ctx, ec, sel, typedObj)
	})
	shardruntime.RegisterObject(splitScope, "__Schema", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.Schema)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Schema", obj))
		}
		return ___Schema(ctx, ec, sel, typedObj)
	})
	shardruntime.RegisterObject(splitScope, "__Type", func(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj any) graphql.Marshaler {
		typedObj, ok := obj.(*introspection.Type)
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object __Type", obj))
		}
		return ___Type(ctx, ec, sel, typedObj)
	})
}

var __DirectiveImplementors = []string{"__Directive"}

func ___Directive(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.ResolveField(ctx, "__Directive", "name", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__Directive", "description", field, obj)
		case "isRepeatable":
			out.Values[i] = ec.ResolveField(ctx, "__Directive", "isRepeatable", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.ResolveField(ctx, "__Directive", "locations", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.ResolveField(ctx, "__Directive", "args", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func ___EnumValue(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.ResolveField(ctx, "__EnumValue", "name", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__EnumValue", "description", field, obj)
		case "isDeprecated":
			out.Values[i] = ec.ResolveField(ctx, "__EnumValue", "isDeprecated", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.ResolveField(ctx, "__EnumValue", "deprecationReason", field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func ___Field(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "name", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "description", field, obj)
		case "args":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "args", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "type", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "isDeprecated", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.ResolveField(ctx, "__Field", "deprecationReason", field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func ___InputValue(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "name", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "description", field, obj)
		case "type":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "type", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "defaultValue", field, obj)
		case "isDeprecated":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "isDeprecated", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.ResolveField(ctx, "__InputValue", "deprecationReason", field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func ___Schema(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "description", field, obj)
		case "types":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "types", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "queryType", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "mutationType", field, obj)
		case "subscriptionType":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "subscriptionType", field, obj)
		case "directives":
			out.Values[i] = ec.ResolveField(ctx, "__Schema", "directives", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func ___Type(ctx context.Context, ec shardruntime.ObjectExecutionContext, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.GetOperationContext(), sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "kind", field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "name", field, obj)
		case "description":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "description", field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "specifiedByURL", field, obj)
		case "fields":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "fields", field, obj)
		case "interfaces":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "interfaces", field, obj)
		case "possibleTypes":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "possibleTypes", field, obj)
		case "enumValues":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "enumValues", field, obj)
		case "inputFields":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "inputFields", field, obj)
		case "ofType":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "ofType", field, obj)
		case "isOneOf":
			out.Values[i] = ec.ResolveField(ctx, "__Type", "isOneOf", field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	ec.AddDeferred(int32(len(deferred)))

	for label, dfs := range deferred {
		ec.ProcessDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}
