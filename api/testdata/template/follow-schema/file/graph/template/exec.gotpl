{{/* Context object: codegen.Data */}}
{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "sync/atomic" }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}
{{ reserveImport "embed"  }}

{{ reserveImport "github.com/vektah/gqlparser/v2" "gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}

{{ if eq .Config.Exec.Layout "single-file" }}
	// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
	func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
		return &executableSchema{
		 	schema: cfg.Schema,
			resolvers: cfg.Resolvers,
			directives: cfg.Directives,
			complexity: cfg.Complexity,
		}
	}

	type Config struct {
		Schema    *ast.Schema
		Resolvers  ResolverRoot
		Directives DirectiveRoot
		Complexity ComplexityRoot
	}

	type ResolverRoot interface {
	{{- range $object := .Objects -}}
		{{ if $object.HasResolvers -}}
			{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
		{{ end }}
	{{- end }}
	{{- range $object := .Inputs -}}
	{{ if $object.HasResolvers -}}
		{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
	{{ end }}
{{- end }}
}

	type DirectiveRoot struct {
	{{ range $directive := .UserDirectives }}
		{{- $directive.Declaration }}
	{{ end }}
	}

	type ComplexityRoot struct {
	{{- if not .Config.OmitComplexity }}
	{{ range $object := .Objects }}
		{{ if not $object.IsReserved -}}
			{{ ucFirst $object.Name }} struct {
			{{ range $_, $fields := $object.UniqueFields }}
				{{- $field := index $fields 0 -}}
				{{ if not $field.IsReserved -}}
					{{ $field.GoFieldName }} {{ $field.ComplexitySignature }}
				{{ end }}
			{{- end }}
			}
		{{- end }}
	{{ end }}
	{{- end }}
	}
{{ end }}

{{ range $object := .Objects -}}
	{{ if $object.HasResolvers }}
		type {{ucFirst $object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $object := .Inputs -}}
	{{ if $object.HasResolvers }}
		type {{$object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $directive := .BuiltInDirectives }}
	var (
		{{- $directive.FunctionImpl }}
	)
{{ end }}

{{ if eq .Config.Exec.Layout "single-file" }}
	type executableSchema struct {
		schema    *ast.Schema
		resolvers  ResolverRoot
		directives DirectiveRoot
		complexity ComplexityRoot
	}

	func (e *executableSchema) Schema() *ast.Schema {
		if e.schema != nil {
        		return e.schema
		}
		return parsedSchema
	}

	func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
		ec := executionContext{nil, e, 0, 0, nil}
		_ = ec
		{{ if not .Config.OmitComplexity -}}
		switch typeName + "." + field {
		{{ range $object := .Objects }}
			{{ if not $object.IsReserved }}
				{{ range $_, $fields := $object.UniqueFields }}
					{{- $len := len $fields }}
					{{- range $i, $field := $fields }}
						{{- $last := eq (add $i 1) $len }}
						{{- if not $field.IsReserved }}
							{{- if eq $i 0 }}case {{ end }}"{{$object.Name}}.{{$field.Name}}"{{ if not $last }},{{ else }}:
								if e.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}} == nil {
									break
								}
								{{ if $field.Args }}
									args, err := ec.{{ $field.ArgsFunc }}(context.TODO(),rawArgs)
									if err != nil {
										return 0, false
									}
								{{ end }}
								return e.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}}(childComplexity{{if $field.Args}}, {{$field.ComplexityArgs}} {{ end }}), true
							{{ end }}
						{{- end }}
					{{- end }}
				{{ end }}
			{{ end }}
		{{ end }}
		}
		{{- end }}
		return 0, false
	}

	func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
		rc := graphql.GetOperationContext(ctx)
		ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
		inputUnmarshalMap := graphql.BuildUnmarshalerMap(
			{{- range $input := .Inputs -}}
				{{ if not $input.HasUnmarshal }}
					ec.unmarshalInput{{ $input.Name }},
				{{- end }}
			{{- end }}
		)
		first := true

		switch rc.Operation.Operation {
		{{- if .QueryRoot }} case ast.Query:
			return func(ctx context.Context) *graphql.Response {
				var response graphql.Response
				var data graphql.Marshaler
				if first {
					first = false
					ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
					{{ if .Directives.LocationDirectives "QUERY" -}}
						data = ec._queryMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
							return ec._{{.QueryRoot.Name}}(ctx, rc.Operation.SelectionSet), nil
						})
					{{- else -}}
						data = ec._{{.QueryRoot.Name}}(ctx, rc.Operation.SelectionSet)
					{{- end }}
				} else {
					if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
						result := <-ec.deferredResults
						atomic.AddInt32(&ec.pendingDeferred, -1)
						data = result.Result
						response.Path = result.Path
						response.Label = result.Label
						response.Errors = result.Errors
					} else {
						return nil
					}
				}
				var buf bytes.Buffer
				data.MarshalGQL(&buf)
				response.Data = buf.Bytes()
				if atomic.LoadInt32(&ec.deferred) > 0 {
					hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
					response.HasNext = &hasNext
				}

				return &response
			}
		{{ end }}

		{{- if .MutationRoot }} case ast.Mutation:
			return func(ctx context.Context) *graphql.Response {
				if !first { return nil }
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				{{ if .Directives.LocationDirectives "MUTATION" -}}
					data := ec._mutationMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
						return ec._{{.MutationRoot.Name}}(ctx, rc.Operation.SelectionSet), nil
					})
				{{- else -}}
					data := ec._{{.MutationRoot.Name}}(ctx, rc.Operation.SelectionSet)
				{{- end }}
				var buf bytes.Buffer
				data.MarshalGQL(&buf)

				return &graphql.Response{
					Data:       buf.Bytes(),
				}
			}
		{{ end }}

		{{- if .SubscriptionRoot }} case ast.Subscription:
			{{ if .Directives.LocationDirectives "SUBSCRIPTION" -}}
				next := ec._subscriptionMiddleware(ctx, rc.Operation, func(ctx context.Context) (interface{}, error){
					return ec._{{.SubscriptionRoot.Name}}(ctx, rc.Operation.SelectionSet),nil
				})
			{{- else -}}
				next := ec._{{.SubscriptionRoot.Name}}(ctx, rc.Operation.SelectionSet)
			{{- end }}

			var buf bytes.Buffer
			return func(ctx context.Context) *graphql.Response {
				buf.Reset()
				data := next(ctx)

				if data == nil {
					return nil
				}
				data.MarshalGQL(&buf)

				return &graphql.Response{
					Data:       buf.Bytes(),
				}
			}
		{{ end }}
		default:
			return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
		}
	}

	type executionContext struct {
		*graphql.OperationContext
		*executableSchema
		deferred        int32
		pendingDeferred int32
		deferredResults chan graphql.DeferredResult
	}

	func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
		atomic.AddInt32(&ec.pendingDeferred, 1)
		go func () {
			ctx := graphql.WithFreshResponseContext(dg.Context)
			dg.FieldSet.Dispatch(ctx)
			ds := graphql.DeferredResult{
				Path:   dg.Path,
				Label:  dg.Label,
				Result: dg.FieldSet,
				Errors: graphql.GetErrors(ctx),
			}
			// null fields should bubble up
			if dg.FieldSet.Invalids > 0 {
				ds.Result = graphql.Null
			}
			ec.deferredResults <- ds
		}()
	}

	func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
		if ec.DisableIntrospection {
			return nil, errors.New("introspection disabled")
		}
		return introspection.WrapSchema(ec.Schema()), nil
	}

	func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
		if ec.DisableIntrospection {
			return nil, errors.New("introspection disabled")
		}
		return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
	}

	{{if .HasEmbeddableSources }}
	//go:embed{{- range $source := .AugmentedSources }}{{if $source.Embeddable}} {{$source.RelativePath|quote}}{{end}}{{- end }}
	var sourcesFS embed.FS

	func sourceData(filename string) string {
		data, err := sourcesFS.ReadFile(filename)
		if err != nil {
			panic(fmt.Sprintf("codegen problem: %s not available", filename))
		}
		return string(data)
	}
	{{- end }}

	var sources = []*ast.Source{
	{{- range $source := .AugmentedSources }}
		{Name: {{$source.RelativePath|quote}}, Input: {{if (not $source.Embeddable)}}{{$source.Source|rawQuote}}{{else}}sourceData({{$source.RelativePath|quote}}){{end}}, BuiltIn: {{$source.BuiltIn}}},
	{{- end }}
	}
	var parsedSchema = gqlparser.MustLoadSchema(sources...)
{{ end }}
{{ range $name, $args := .Args }}
func (ec *executionContext) {{ $name }}(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}

	{{- range $i, $arg := . }}
		arg{{$i}}, err := ec.{{ $name }}{{$arg.Name | go}}(ctx, rawArgs)
		if err != nil {
			return nil, err
		}
		args[{{$arg.Name|quote}}] = arg{{$i}}
	{{- end }}
	return args, nil
}

	{{- range $i, $arg := . }}
		func (ec *executionContext) {{ $name }}{{$arg.Name | go}}(
			ctx context.Context,
			rawArgs map[string]interface{},
		) ({{ $arg.TypeReference.GO | ref}}, error) {
			{{- if not .CallArgumentDirectivesWithNull}}
				// We won't call the directive if the argument is null.
				// Set call_argument_directives_with_null to true to call directives
				// even if the argument is null.
				_, ok := rawArgs[{{$arg.Name|quote}}]
				if !ok {
					var zeroVal {{ $arg.TypeReference.GO | ref}}
					return zeroVal, nil
				}
			{{end}}
			ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField({{$arg.Name|quote}}))
			{{- if $arg.ImplDirectives }}
				directive0 := func(ctx context.Context) (interface{}, error) {
					tmp, ok := rawArgs[{{$arg.Name|quote}}]
					if !ok {
						var zeroVal {{ $arg.TypeReference.GO | ref}}
						return zeroVal, nil
					}
					return ec.{{ $arg.TypeReference.UnmarshalFunc }}(ctx, tmp)
				}
				{{ template "implDirectives" $arg }}
				tmp, err := directive{{$arg.ImplDirectives|len}}(ctx)
				if err != nil {
					var zeroVal {{ $arg.TypeReference.GO | ref}}
					return zeroVal, graphql.ErrorOnPath(ctx, err)
				}
				if data, ok := tmp.({{ $arg.TypeReference.GO | ref }}) ; ok {
					return data, nil
				{{- if $arg.TypeReference.IsNilable }}
					} else if tmp == nil {
						var zeroVal {{ $arg.TypeReference.GO | ref}}
						return zeroVal, nil
				{{- end }}
				} else {
					var zeroVal {{ $arg.TypeReference.GO | ref}}
					return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be {{ $arg.TypeReference.GO }}`, tmp))
				}
			{{- else }}
				if tmp, ok := rawArgs[{{$arg.Name|quote}}]; ok {
					return ec.{{ $arg.TypeReference.UnmarshalFunc }}(ctx, tmp)
				}

				var zeroVal {{ $arg.TypeReference.GO | ref}}
				return zeroVal, nil
			{{- end }}
		}
	{{end}}
{{ end }}
{{- range $object := .Objects }}{{- range $field := $object.Fields }}

func (ec *executionContext) _{{$object.Name}}_{{$field.Name}}(ctx context.Context, field graphql.CollectedField{{ if not $object.Root }}, obj {{$object.Reference | ref}}{{end}}) (ret {{ if $object.Stream }}func(ctx context.Context){{ end }}graphql.Marshaler) {
	{{- $null := "graphql.Null" }}
	{{- if $object.Stream }}
		{{- $null = "nil" }}
	{{- end }}
	fc, err := ec.{{ $field.FieldContextFunc }}(ctx, field)
	if err != nil {
		return {{ $null }}
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	{{- if not $.Config.OmitPanicHandler }}
	defer func () {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = {{ $null }}
		}
	}()
	{{- end }}
	{{- if $field.TypeReference.IsRoot }}
		{{- if $field.TypeReference.IsPtr }}
			res := &{{ $field.TypeReference.Elem.GO | ref }}{}
		{{- else }}
			res := {{ $field.TypeReference.GO | ref }}{}
		{{- end }}
		fc.Result = res
		return ec.{{ $field.TypeReference.MarshalFunc }}(ctx, field.Selections, res)
	{{- else}}
		{{- if  $.AllDirectives.LocationDirectives "FIELD" }}
			resTmp := ec._fieldMiddleware(ctx, {{if $object.Root}}nil{{else}}obj{{end}}, func(rctx context.Context) (interface{}, error) {
				{{ template "field" $field }}
			})
		{{ else }}
			resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
				{{ template "field" $field }}
			})
			if err != nil {
				ec.Error(ctx, err)
				return {{ $null }}
			}
		{{- end }}
		if resTmp == nil {
			{{- if $field.TypeReference.GQL.NonNull }}
				if !graphql.HasFieldError(ctx, fc) {
					ec.Errorf(ctx, "must not be null")
				}
			{{- end }}
			return {{ $null }}
		}
		{{- if $object.Stream }}
			return func(ctx context.Context) graphql.Marshaler {
				select {
				case res, ok := <-resTmp.(<-chan {{$field.TypeReference.GO | ref}}):
					if !ok {
						return nil
					}
					return graphql.WriterFunc(func(w io.Writer) {
						w.Write([]byte{'{'})
						graphql.MarshalString(field.Alias).MarshalGQL(w)
						w.Write([]byte{':'})
						ec.{{ $field.TypeReference.MarshalFunc }}(ctx, field.Selections, res).MarshalGQL(w)
						w.Write([]byte{'}'})
					})
				case <-ctx.Done():
					return nil
				}
			}
		{{- else }}
			res := resTmp.({{$field.TypeReference.GO | ref}})
			fc.Result = res
			return ec.{{ $field.TypeReference.MarshalFunc }}(ctx, field.Selections, res)
		{{- end }}
	{{- end }}
}

func (ec *executionContext) {{ $field.FieldContextFunc }}({{ if not $field.Args }}_{{ else }}ctx{{ end }} context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object: {{quote $field.Object.Name}},
		Field: field,
		IsMethod: {{or $field.IsMethod $field.IsResolver}},
		IsResolver: {{ $field.IsResolver }},
		Child: func (ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			{{- if not $field.TypeReference.Definition.Fields }}
				return nil, errors.New("field of type {{ $field.TypeReference.Definition.Name }} does not have child fields")
			{{- else if ne $field.TypeReference.Definition.Kind "OBJECT" }}
				return nil, errors.New("FieldContext.Child cannot be called on type {{ $field.TypeReference.Definition.Kind }}")
			{{- else }}
				switch field.Name {
					{{- range $f := $field.TypeReference.Definition.Fields }}
						case "{{ $f.Name }}":
							return ec.{{ $field.ChildFieldContextFunc $f.Name }}(ctx, field)
					{{- end }}
				}
				return nil, fmt.Errorf("no field named %q was found under type {{ $field.TypeReference.Definition.Name }}", field.Name)
			{{- end }}
		},
	}
	{{- if $field.Args }}
		{{- if not $.Config.OmitPanicHandler }}
		defer func () {
			if r := recover(); r != nil {
				err = ec.Recover(ctx, r)
				ec.Error(ctx, err)
			}
		}()
		{{- end }}
		ctx = graphql.WithFieldContext(ctx, fc)
		if fc.Args, err = ec.{{ $field.ArgsFunc }}(ctx, field.ArgumentMap(ec.Variables)); err != nil {
			ec.Error(ctx, err)
			return fc, err
		}
	{{- end }}
	return fc, nil
}

{{- end }}{{- end}}

{{ define "field" }}
	{{- if .HasDirectives -}}
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx  // use context from middleware stack in children
			{{ template "fieldDefinition" . }}
		}
		{{ template "implDirectives" . }}
		tmp, err := directive{{.ImplDirectives|len}}(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
		    return nil, nil
		}
		if data, ok := tmp.({{if .Stream}}<-chan {{end}}{{ .TypeReference.GO | ref }}) ; ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be {{if .Stream}}<-chan {{end}}{{ .TypeReference.GO }}`, tmp)
	{{- else -}}
		ctx = rctx  // use context from middleware stack in children
		{{ template "fieldDefinition" . }}
	{{- end -}}
{{ end }}

{{ define "fieldDefinition" }}
	{{- if .IsResolver -}}
		return ec.resolvers.{{ .ShortInvocation }}
	{{- else if .IsMap -}}
		switch v := {{.GoReceiverName}}[{{.Name|quote}}].(type) {
		case {{if .Stream}}<-chan {{end}}{{.TypeReference.GO | ref}}:
			return v, nil
		case {{if .Stream}}<-chan {{end}}{{.TypeReference.Elem.GO | ref}}:
			return &v, nil
		case nil:
			return ({{.TypeReference.GO | ref}})(nil), nil
		default:
			return nil, fmt.Errorf("unexpected type %T for field %s", v, {{ .Name | quote}})
		}
	{{- else if .IsMethod -}}
		{{- if .VOkFunc -}}
			v, ok := {{.GoReceiverName}}.{{.GoFieldName}}({{ .CallArgs }})
			if !ok {
				return nil, nil
			}
			return v, nil
		{{- else if .NoErr -}}
			return {{.GoReceiverName}}.{{.GoFieldName}}({{ .CallArgs }}), nil
		{{- else -}}
			return {{.GoReceiverName}}.{{.GoFieldName}}({{ .CallArgs }})
		{{- end -}}
	{{- else if .IsVariable -}}
		return {{.GoReceiverName}}.{{.GoFieldName}}, nil
	{{- end }}
{{- end }}
{{- range $input := .Inputs }}
	{{- if not .HasUnmarshal }}
	{{- $it := "it" }}
	{{- if .PointersInUnmarshalInput }}
	  {{- $it = "&it" }}
	{{- end }}
	func (ec *executionContext) unmarshalInput{{ .Name }}(ctx context.Context, obj interface{}) ({{ if .PointersInUnmarshalInput }}*{{ end }}{{.Type | ref}}, error) {
		{{- if $input.IsMap }}
			it := make(map[string]interface{}, len(obj.(map[string]interface{})))
		{{- else }}
			var it {{.Type | ref}}
		{{- end }}
		asMap := map[string]interface{}{}
		for k, v := range obj.(map[string]interface{}) {
			asMap[k] = v
		}
		{{ range $field := .Fields}}
			{{- if notNil "Default" $field }}
				if _, present := asMap[{{$field.Name|quote}}] ; !present {
					asMap[{{$field.Name|quote}}] = {{ $field.Default | dump }}
				}
			{{- end}}
		{{- end }}

		fieldsInOrder := [...]string{ {{ range .Fields }}{{ quote .Name }},{{ end }} }
		for _, k := range fieldsInOrder {
			v, ok := asMap[k]
			if !ok {
				continue
			}
			switch k {
			{{- range $field := .Fields }}
			case {{$field.Name|quote}}:
				{{- $lhs := (printf "it.%s" $field.GoFieldName) }}
				{{- if $input.IsMap }}
					{{- $lhs = (printf "it[%q]" $field.Name) }}
				{{- end }}
				ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField({{$field.Name|quote}}))
				{{- if $field.ImplDirectives }}
					directive0 := func(ctx context.Context) (interface{}, error) { return ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v) }
					{{ template "implDirectives" $field }}
					tmp, err := directive{{$field.ImplDirectives|len}}(ctx)
					if err != nil {
						return {{$it}}, graphql.ErrorOnPath(ctx, err)
					}
					if data, ok := tmp.({{ $field.TypeReference.GO | ref }}) ; ok {
						{{- if $field.IsResolver }}
							if err = ec.resolvers.{{ $field.ShortInvocation }}; err != nil {
								return {{$it}}, err
							}
						{{- else }}
							{{- if $field.TypeReference.IsOmittable }}
								{{ $lhs }} = graphql.OmittableOf(data)
							{{- else }}
								{{ $lhs }} = data
							{{- end }}
						{{- end }}
					{{- if $field.TypeReference.IsNilable }}
						{{- if not $field.IsResolver }}
						} else if tmp == nil {
							{{- if $field.TypeReference.IsOmittable }}
								{{ $lhs }} = graphql.OmittableOf[{{ $field.TypeReference.GO | ref }}](nil)
							{{- else }}
								{{ $lhs }} = nil
							{{- end }}
						{{- end }}
					{{- end }}
					} else {
						err := fmt.Errorf(`unexpected type %T from directive, should be {{ $field.TypeReference.GO }}`, tmp)
						return {{$it}}, graphql.ErrorOnPath(ctx, err)
					}
				{{- else }}
					{{- if $field.IsResolver }}
						data, err := ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v)
						if err != nil {
							return {{$it}}, err
						}
						if err = ec.resolvers.{{ $field.ShortInvocation }}; err != nil {
							return {{$it}}, err
						}
					{{- else }}
						data, err := ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v)
						if err != nil {
							return {{$it}}, err
						}
						{{- if $field.TypeReference.IsOmittable }}
							{{ $lhs }} = graphql.OmittableOf(data)
						{{- else }}
							{{ $lhs }} = data
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
			}
		}

		return {{$it}}, nil
	}
	{{- end }}
{{ end }}
{{- range $interface := .Interfaces }}

func (ec *executionContext) _{{$interface.Name}}(ctx context.Context, sel ast.SelectionSet, obj {{$interface.Type | ref}}) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	{{- range $implementor := $interface.Implementors }}
		case {{$implementor.Type | ref}}:
			{{- if $implementor.CanBeNil }}
				if obj == nil {
					return graphql.Null
				}
			{{- end }}
			return ec._{{$implementor.Name}}(ctx, sel, {{ if $implementor.TakeRef }}&{{ end }}obj)
	{{- end }}
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

{{- end }}
{{- range $object := .Objects }}

var {{ $object.Name|lcFirst}}Implementors = {{$object.Implementors}}

{{- if .Stream }}
func (ec *executionContext) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, {{$object.Name|lcFirst}}Implementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: {{$object.Name|quote}},
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	{{- range $field := $object.Fields }}
	case "{{$field.Name}}":
		return ec._{{$object.Name}}_{{$field.Name}}(ctx, fields[0])
	{{- end }}
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}
{{- else }}
func (ec *executionContext) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet{{ if not $object.Root }},obj {{$object.Reference | ref }}{{ end }}) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, {{$object.Name|lcFirst}}Implementors)
	{{- if $object.Root }}
		ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
			Object: {{$object.Name|quote}},
		})
	{{end}}

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		{{- if $object.Root }}
			innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
				Object: field.Name,
				Field: field,
			})
		{{end}}
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString({{$object.Name|quote}})
		{{- range $field := $object.Fields }}
		case "{{$field.Name}}":
			{{- if $field.IsConcurrent }}
				field := field

				innerFunc := func(ctx context.Context, {{ if $field.TypeReference.GQL.NonNull }}fs{{ else }}_{{ end }} *graphql.FieldSet) (res graphql.Marshaler) {
					{{- if not $.Config.OmitPanicHandler }}
					defer func() {
						if r := recover(); r != nil {
							ec.Error(ctx, ec.Recover(ctx, r))
						}
					}()
					{{- end }}
					res = ec._{{$object.Name}}_{{$field.Name}}(ctx, field{{if not $object.Root}}, obj{{end}})
					{{- if $field.TypeReference.GQL.NonNull }}
						if res == graphql.Null {
							{{- if $object.IsConcurrent }}
								atomic.AddUint32(&fs.Invalids, 1)
							{{- else }}
								fs.Invalids++
							{{- end }}
						}
					{{- end }}
					return res
				}

				{{if $object.Root}}
					rrm := func(ctx context.Context) graphql.Marshaler {
						return ec.OperationContext.RootResolverMiddleware(ctx,
							func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
					}
				{{end}}

				{{if not $object.Root}}
					if field.Deferrable != nil {
						dfs, ok := deferred[field.Deferrable.Label]
						di := 0
						if ok {
							dfs.AddField(field)
							di = len(dfs.Values) - 1
						} else {
							dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
							deferred[field.Deferrable.Label] = dfs
						}
						dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
							return innerFunc(ctx, dfs)
						})

						// don't run the out.Concurrently() call below
						out.Values[i] = graphql.Null
						continue
					}
				{{end}}

				out.Concurrently(i, func(ctx context.Context) graphql.Marshaler {
					{{- if $object.Root -}}
						return rrm(innerCtx)
					{{- else -}}
						return innerFunc(ctx, out)
					{{- end -}}
				})
			{{- else }}
				{{- if $object.Root -}}
					out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
						return ec._{{$object.Name}}_{{$field.Name}}(ctx, field)
					})
				{{- else -}}
					out.Values[i] = ec._{{$object.Name}}_{{$field.Name}}(ctx, field, obj)
				{{- end -}}

				{{- if $field.TypeReference.GQL.NonNull }}
					if out.Values[i] == graphql.Null {
						{{- if $object.IsConcurrent }}
							atomic.AddUint32(&out.Invalids, 1)
						{{- else }}
							out.Invalids++
						{{- end }}
					}
				{{- end }}
			{{- end }}
		{{- end }}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 { return graphql.Null }

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}
{{- end }}

{{- end }}
{{- range $type := .ReferencedTypes }}
	{{ with $type.UnmarshalFunc }}
		func (ec *executionContext) {{ . }}(ctx context.Context, v interface{}) ({{ $type.GO | ref }}, error) {
			{{- if and $type.IsNilable (not $type.GQL.NonNull) (not $type.IsPtrToPtr) }}
				if v == nil { return nil, nil }
			{{- end }}
			{{- if or $type.IsPtrToSlice $type.IsPtrToIntf }}
				res, err := ec.{{ $type.Elem.UnmarshalFunc }}(ctx, v)
				return &res, graphql.ErrorOnPath(ctx, err)
			{{- else if $type.IsSlice }}
				var vSlice []interface{}
				if v != nil {
					vSlice = graphql.CoerceList(v)
				}
				var err error
				res := make([]{{$type.GO.Elem | ref}}, len(vSlice))
				for i := range vSlice {
					ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
					res[i], err = ec.{{ $type.Elem.UnmarshalFunc }}(ctx, vSlice[i])
					if err != nil {
						return nil, err
					}
				}
				return res, nil
			{{- else if and $type.IsPtrToPtr (not $type.Unmarshaler) (not $type.IsMarshaler) }}
				var pres {{ $type.Elem.GO | ref }}
				if v != nil {
					res, err := ec.{{ $type.Elem.UnmarshalFunc }}(ctx, v)
					if err != nil {
						return nil, graphql.ErrorOnPath(ctx, err)
					}
					pres = res
				}
				return &pres, nil
			{{- else }}
				{{- if $type.Unmarshaler }}
					{{- if $type.HasEnumValues }}
						tmp, err := {{ $type.Unmarshaler | call }}(v)
						res := {{ $type.UnmarshalFunc }}[tmp]
					{{- else if $type.CastType }}
						{{- if $type.IsContext }}
							tmp, err := {{ $type.Unmarshaler | call }}(ctx, v)
						{{- else }}
							tmp, err := {{ $type.Unmarshaler | call }}(v)
						{{- end }}
						{{- if and $type.IsNilable $type.Elem }}
							res := {{ $type.Elem.GO | ref }}(tmp)
						{{- else}}
							res := {{ $type.GO | ref }}(tmp)
						{{- end }}
					{{- else}}
						{{- if $type.IsContext }}
							res, err := {{ $type.Unmarshaler | call }}(ctx, v)
						{{- else }}
							res, err := {{ $type.Unmarshaler | call }}(v)
						{{- end }}
					{{- end }}
					{{- if and $type.IsTargetNilable (not $type.IsNilable) }}
						return *res, graphql.ErrorOnPath(ctx, err)
					{{- else if and (not $type.IsTargetNilable) $type.IsNilable }}
						return &res, graphql.ErrorOnPath(ctx, err)
					{{- else}}
						return res, graphql.ErrorOnPath(ctx, err)
					{{- end }}
				{{- else if $type.IsMarshaler }}
					{{- if and $type.IsNilable $type.Elem }}
						var res = new({{ $type.Elem.GO | ref }})
					{{- else}}
						var res {{ $type.GO | ref }}
					{{- end }}
					{{- if $type.IsContext }}
						err := res.UnmarshalGQLContext(ctx, v)
					{{- else }}
						err := res.UnmarshalGQL(v)
					{{- end }}
					return res, graphql.ErrorOnPath(ctx, err)
				{{- else }}
					res, err := ec.unmarshalInput{{ $type.GQL.Name }}(ctx, v)
					{{- if and $type.IsNilable (not $type.IsMap) (not $type.PointersInUnmarshalInput) }}
						return &res, graphql.ErrorOnPath(ctx, err)
					{{- else if and (not $type.IsNilable) $type.PointersInUnmarshalInput }}
						return *res, graphql.ErrorOnPath(ctx, err)
					{{- else }}
						return res, graphql.ErrorOnPath(ctx, err)
					{{- end }}
				{{- end }}
			{{- end }}
		}
	{{- end }}

	{{ with $type.MarshalFunc }}
		func (ec *executionContext) {{ . }}(ctx context.Context, sel ast.SelectionSet, v {{ $type.GO | ref }}) graphql.Marshaler {
			{{- if or $type.IsPtrToSlice $type.IsPtrToIntf }}
				return ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, *v)
			{{- else if $type.IsSlice }}
				{{- if not $type.GQL.NonNull }}
					if v == nil {
						return graphql.Null
					}
				{{- end }}
				ret := make(graphql.Array, len(v))
				{{- if not $type.IsScalar }}
					var wg sync.WaitGroup
					isLen1 := len(v) == 1
					if !isLen1 {
						wg.Add(len(v))
					}
				{{- end }}
				for i := range v {
					{{- if not $type.IsScalar }}
						i := i
						fc := &graphql.FieldContext{
							Index: &i,
							Result: &v[i],
						}
						ctx := graphql.WithFieldContext(ctx, fc)
						f := func(i int) {
							{{- if not $.Config.OmitPanicHandler }}
							defer func() {
								if r := recover(); r != nil {
									ec.Error(ctx, ec.Recover(ctx, r))
									ret = nil
								}
							}()
							{{- end }}
							if !isLen1 {
								defer wg.Done()
							}
							ret[i] = ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, v[i])
						}
						if isLen1 {
							f(i)
						} else {
							go f(i)
						}
					{{ else }}
						ret[i] = ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, v[i])
					{{- end }}
				}
				{{ if not $type.IsScalar }} wg.Wait() {{ end }}
				{{ if $type.Elem.GQL.NonNull }}
					for _, e := range ret {
						if e == graphql.Null {
							return graphql.Null
						}
					}
				{{ end }}
				return ret
			{{- else if and $type.IsPtrToPtr (not $type.Unmarshaler) (not $type.IsMarshaler) }}
				if v == nil {
					return graphql.Null
				}
				return ec.{{ $type.Elem.MarshalFunc }}(ctx, sel, *v)
			{{- else }}
				{{- if $type.IsNilable }}
					if v == nil {
						{{- if $type.GQL.NonNull }}
							if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
								ec.Errorf(ctx, "the requested element is null which the schema does not allow")
							}
						{{- end }}
						return graphql.Null
					}
				{{- end }}
				{{- if $type.IsMarshaler }}
					{{- if $type.IsContext }}
						return graphql.WrapContextMarshaler(ctx, v)
					{{- else }}
						return v
					{{- end }}
				{{- else if $type.Marshaler }}
					{{- $v := "v" }}
					{{- if and $type.IsTargetNilable (not $type.IsNilable) }}
						{{- $v = "&v" }}
					{{- else if and (not $type.IsTargetNilable) $type.IsNilable }}
						{{- $v = "*v" }}
					{{- end }}
					{{- if $type.HasEnumValues }}
						{{- $v = printf "%v[%v]" $type.MarshalFunc $v }}
					{{- else if $type.CastType }}
						{{- $v = printf "%v(%v)" ($type.CastType | ref) $v}}
					{{- end }}
					res := {{ $type.Marshaler | call }}({{ $v }})
					{{- if $type.GQL.NonNull }}
						if res == graphql.Null {
							if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
								ec.Errorf(ctx, "the requested element is null which the schema does not allow")
							}
						}
					{{- end }}
					{{- if $type.IsContext }}
						return graphql.WrapContextMarshaler(ctx, res)
					{{- else }}
						return res
					{{- end }}
				{{- else if $type.IsRoot }}
					{{- if eq $type.Definition.Name "Subscription" }}
						res := ec._{{$type.Definition.Name}}(ctx, sel)
						return res(ctx)
					{{- else }}
						return ec._{{$type.Definition.Name}}(ctx, sel)
					{{- end }}
				{{- else }}
					return ec._{{$type.Definition.Name}}(ctx, sel, {{ if not $type.IsNilable}}&{{end}} v)
				{{- end }}
			{{- end }}
		}
	{{- end }}

	{{- if $type.HasEnumValues }}
	{{- $enum := $type.GO }}
	{{- if $type.IsNilable }}
		{{- $enum = $type.GO.Elem }}
	{{- end }}
	var (
		{{ $type.UnmarshalFunc }} = map[string]{{ $enum | ref }}{
		{{- range $value := $type.EnumValues }}
			"{{ $value.Definition.Name }}": {{ $value.Object | obj }},
		{{- end }}
		}
		{{ $type.MarshalFunc }} = map[{{ $enum | ref }}]string{
		{{- range $value := $type.EnumValues }}
			 {{ $value.Object | obj }}: "{{ $value.Definition.Name }}",
		{{- end }}
		}
	 )
	{{- end }}
{{- end }}
