{{ $useFunctionSyntaxForExecutionContext := .Config.UseFunctionSyntaxForExecutionContext }}

{{- range $input := .Inputs }}
	{{- if not .HasUnmarshal }}
	{{- $it := "it" }}
	{{- if .PointersInUnmarshalInput }}
	  {{- $it = "&it" }}
	{{- end }}
	{{ if $useFunctionSyntaxForExecutionContext -}}
	func unmarshalInput{{ .Name }}(ctx context.Context, ec *executionContext, obj any) ({{ if .PointersInUnmarshalInput }}*{{ end }}{{.Type | ref}}, error) {
	{{- else -}}
	func (ec *executionContext) unmarshalInput{{ .Name }}(ctx context.Context, obj any) ({{ if .PointersInUnmarshalInput }}*{{ end }}{{.Type | ref}}, error) {
	{{- end }}
		{{- if $input.IsMap }}
			it := make(map[string]any, len(obj.(map[string]any)))
		{{- else }}
			var it {{.Type | ref}}
		{{- end }}
		asMap := map[string]any{}
		for k, v := range obj.(map[string]any) {
			asMap[k] = v
		}
		{{ range $field := .Fields}}
			{{- if notNil "Default" $field }}
				if _, present := asMap[{{$field.Name|quote}}] ; !present {
					asMap[{{$field.Name|quote}}] = {{ $field.Default | dump }}
				}
			{{- end}}
		{{- end }}

		fieldsInOrder := [...]string{ {{ range .Fields }}{{ quote .Name }},{{ end }} }
		for _, k := range fieldsInOrder {
			v, ok := asMap[k]
			if !ok {
				continue
			}
			switch k {
			{{- range $field := .Fields }}
			case {{$field.Name|quote}}:
				{{- $lhs := (printf "it.%s" $field.GoFieldName) }}
				{{- if $input.IsMap }}
					{{- $lhs = (printf "it[%q]" $field.Name) }}
				{{- end }}
				ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField({{$field.Name|quote}}))
				{{- if $field.ImplDirectives }}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					directive0 := func(ctx context.Context) (any, error) { return {{ $field.TypeReference.UnmarshalFunc }}(ctx, ec, v) }
					{{- else -}}
					directive0 := func(ctx context.Context) (any, error) { return ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v) }
					{{- end }}
					{{ template "implDirectives" (dict "Field" $field "UseFunctionSyntaxForExecutionContext" $useFunctionSyntaxForExecutionContext) }}
					tmp, err := directive{{$field.ImplDirectives|len}}(ctx)
					if err != nil {
						return {{$it}}, graphql.ErrorOnPath(ctx, err)
					}
					if data, ok := tmp.({{ $field.TypeReference.GO | ref }}) ; ok {
						{{- if $field.IsResolver }}
							if err = ec.Resolvers.{{ $field.ShortInvocation }}; err != nil {
								return {{$it}}, err
							}
						{{- else }}
							{{- if $field.TypeReference.IsOmittable }}
								{{ $lhs }} = graphql.OmittableOf(data)
							{{- else }}
								{{ $lhs }} = data
							{{- end }}
						{{- end }}
					{{- if $field.TypeReference.IsNilable }}
						{{- if not $field.IsResolver }}
						} else if tmp == nil {
							{{- if $field.TypeReference.IsOmittable }}
								{{ $lhs }} = graphql.OmittableOf[{{ $field.TypeReference.GO | ref }}](nil)
							{{- else }}
								{{ $lhs }} = nil
							{{- end }}
						{{- end }}
					{{- end }}
					} else {
						err := fmt.Errorf(`unexpected type %T from directive, should be {{ $field.TypeReference.GO }}`, tmp)
						return {{$it}}, graphql.ErrorOnPath(ctx, err)
					}
				{{- else }}
					{{- if $field.IsResolver }}
						{{ if $useFunctionSyntaxForExecutionContext -}}
						data, err := {{ $field.TypeReference.UnmarshalFunc }}(ctx, ec, v)
						{{- else -}}
						data, err := ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v)
						{{- end }}
						if err != nil {
							return {{$it}}, err
						}
						if err = ec.Resolvers.{{ $field.ShortInvocation }}; err != nil {
							return {{$it}}, err
						}
					{{- else }}
						{{ if $useFunctionSyntaxForExecutionContext -}}
						data, err := {{ $field.TypeReference.UnmarshalFunc }}(ctx, ec, v)
						{{- else -}}
						data, err := ec.{{ $field.TypeReference.UnmarshalFunc }}(ctx, v)
						{{- end }}
						if err != nil {
							return {{$it}}, err
						}
						{{- if $field.TypeReference.IsOmittable }}
							{{ $lhs }} = graphql.OmittableOf(data)
						{{- else }}
							{{ $lhs }} = data
						{{- end }}
					{{- end }}
				{{- end }}
			{{- end }}
			}
		}

		{{- if $input.InputObjectDirectives }}
		// Execute INPUT_OBJECT level directives (e.g., @oneOf, @directive3)
		// These run after all fields have been unmarshaled
		{{ if $useFunctionSyntaxForExecutionContext -}}
		directive0 := func(ctx context.Context) (any, error) { return {{$it}}, nil }
		{{- else -}}
		directive0 := func(ctx context.Context) (any, error) { return {{$it}}, nil }
		{{- end }}
		{{- range $i, $directive := $input.InputObjectDirectives }}
		directive{{add $i 1}} := func(ctx context.Context) (any, error) {
			{{- range $arg := $directive.Args }}
				{{- if notNil "Value" $arg }}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					{{ $arg.VarName }}, err := {{ $arg.TypeReference.UnmarshalFunc }}(ctx, ec, {{ $arg.Value | dump }})
					{{- else -}}
					{{ $arg.VarName }}, err := ec.{{ $arg.TypeReference.UnmarshalFunc }}(ctx, {{ $arg.Value | dump }})
					{{- end }}
					if err != nil {
						return {{$it}}, err
					}
				{{- else if notNil "Default" $arg }}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					{{ $arg.VarName }}, err := {{ $arg.TypeReference.UnmarshalFunc }}(ctx, ec, {{ $arg.Default | dump }})
					{{- else -}}
					{{ $arg.VarName }}, err := ec.{{ $arg.TypeReference.UnmarshalFunc }}(ctx, {{ $arg.Default | dump }})
					{{- end }}
					if err != nil {
						return {{$it}}, err
					}
				{{- end }}
			{{- end }}
			{{- if not $directive.IsBuiltIn}}
				if {{$directive.CallPath}} == nil {
					return {{$it}}, errors.New("directive {{$directive.Name}} is not implemented")
				}
			{{- end}}
			return {{$directive.CallPath}}(ctx, asMap, directive{{$i}})
		}
		{{- end }}
		tmp, err := directive{{$input.InputObjectDirectives|len}}(ctx)
		if err != nil {
			return {{$it}}, err
		}
		if data, ok := tmp.({{ if $input.PointersInUnmarshalInput }}*{{ end }}{{$input.Type | ref}}) ; ok {
			return data, nil
		}
		return {{$it}}, fmt.Errorf(`unexpected type %T from INPUT_OBJECT directive, should be {{ if $input.PointersInUnmarshalInput }}*{{ end }}{{$input.Type | ref}}`, tmp)
		{{- else }}
		return {{$it}}, nil
		{{- end }}
	}
	{{- end }}
{{ end }}

