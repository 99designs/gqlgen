{{/* Context object: codegen.Data */}}
{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "sync/atomic" }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}
{{ reserveImport "embed"  }}

{{ reserveImport "golang.org/x/sync/semaphore"}}
{{ reserveImport "github.com/vektah/gqlparser/v2" "gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{- if .HasBatchResolverFields }}
{{ reserveImport "github.com/vektah/gqlparser/v2/gqlerror" }}
{{- end }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}

{{ $useFunctionSyntaxForExecutionContext := .Config.UseFunctionSyntaxForExecutionContext }}

{{ if eq .Config.Exec.Layout "single-file" }}
	// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
	func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
		return &executableSchema{
		 	schema: cfg.Schema,
			resolvers: cfg.Resolvers,
			directives: cfg.Directives,
			complexity: cfg.Complexity,
		}
	}

	type Config struct {
		Schema    *ast.Schema
		Resolvers  ResolverRoot
		Directives DirectiveRoot
		Complexity ComplexityRoot
	}

	type ResolverRoot interface {
	{{- range $object := .Objects -}}
		{{ if $object.HasResolvers -}}
			{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
		{{ end }}
	{{- end }}
	{{- range $object := .Inputs -}}
	{{ if $object.HasResolvers -}}
		{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
	{{ end }}
{{- end }}
}

	type DirectiveRoot struct {
	{{ range $directive := .UserDirectives }}
		{{- $directive.Declaration }}
	{{ end }}
	}

	type ComplexityRoot struct {
	{{- if not .Config.OmitComplexity }}
	{{ range $object := .Objects }}
		{{ if not $object.IsReserved -}}
			{{ ucFirst $object.Name }} struct {
			{{ range $_, $fields := $object.UniqueFields }}
				{{- $field := index $fields 0 -}}
				{{ if not $field.IsReserved -}}
					{{ $field.GoFieldName }} {{ $field.ComplexitySignature }}
				{{ end }}
			{{- end }}
			}
		{{- end }}
	{{ end }}
	{{- end }}
	}
{{ end }}

{{ range $object := .Objects -}}
	{{ if $object.HasResolvers }}
		type {{ucFirst $object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsBatch }}
				{{- $field.GoFieldName}}{{ $field.ShortBatchResolverDeclaration }}
			{{- else if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $object := .Inputs -}}
	{{ if $object.HasResolvers }}
		type {{$object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $directive := .BuiltInDirectives }}
	var (
		{{- $directive.FunctionImpl }}
	)
{{ end }}

{{ if eq .Config.Exec.Layout "single-file" }}
	type executableSchema struct {
		schema    *ast.Schema
		resolvers  ResolverRoot
		directives DirectiveRoot
		complexity ComplexityRoot
	}

	func (e *executableSchema) Schema() *ast.Schema {
		if e.schema != nil {
        		return e.schema
		}
		return parsedSchema
	}

	func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
		ec := executionContext{nil, e, 0, 0, nil}
		_ = ec
		{{ if not .Config.OmitComplexity -}}
		switch typeName + "." + field {
		{{ range $object := .Objects }}
			{{ if not $object.IsReserved }}
				{{ range $_, $fields := $object.UniqueFields }}
					{{- $len := len $fields }}
					{{- range $i, $field := $fields }}
						{{- $last := eq (add $i 1) $len }}
						{{- if not $field.IsReserved }}
							{{- if eq $i 0 }}case {{ end }}"{{$object.Name}}.{{$field.Name}}"{{ if not $last }},{{ else }}:
								if e.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}} == nil {
									break
								}
								{{ if $field.Args }}
									{{ if $useFunctionSyntaxForExecutionContext -}}
									args, err := {{ $field.ArgsFunc }}(ctx, &ec, rawArgs)
									{{- else -}}
									args, err := ec.{{ $field.ArgsFunc }}(ctx,rawArgs)
									{{- end }}
									if err != nil {
										return 0, false
									}
								{{ end }}
								return e.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}}(childComplexity{{if $field.Args}}, {{$field.ComplexityArgs}} {{ end }}), true
							{{- end }}
						{{- end }}
					{{- end }}
				{{ end }}
			{{ end }}
		{{ end }}
		}
		{{- end }}
		return 0, false
	}

	func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
		opCtx := graphql.GetOperationContext(ctx)
		ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
		inputUnmarshalMap := graphql.BuildUnmarshalerMap(
			{{- range $input := .Inputs -}}
				{{ if not $input.HasUnmarshal }}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					unmarshalInput{{ $input.Name }},
					{{- else -}}
					ec.unmarshalInput{{ $input.Name }},
					{{- end }}
				{{- end }}
			{{- end }}
		)
		first := true

		switch opCtx.Operation.Operation {
		{{- if .QueryRoot }} case ast.Query:
			return func(ctx context.Context) *graphql.Response {
				var response graphql.Response
				var data graphql.Marshaler
				if first {
					first = false
					ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
					{{ if .Directives.LocationDirectives "QUERY" -}}
						{{ if $useFunctionSyntaxForExecutionContext -}}
						data = _queryMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
							return _{{.QueryRoot.Name}}(ctx, ec, opCtx.Operation.SelectionSet), nil
						{{- else -}}
						data = ec._queryMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
							return ec._{{.QueryRoot.Name}}(ctx, opCtx.Operation.SelectionSet), nil
						{{- end }}
						})
					{{- else -}}
						{{ if $useFunctionSyntaxForExecutionContext -}}
						data = _{{.QueryRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
						{{- else -}}
						data = ec._{{.QueryRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
						{{- end }}
					{{- end }}
				} else {
					if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
						result := <-ec.deferredResults
						atomic.AddInt32(&ec.pendingDeferred, -1)
						data = result.Result
						response.Path = result.Path
						response.Label = result.Label
						response.Errors = result.Errors
					} else {
						return nil
					}
				}
				var buf bytes.Buffer
				data.MarshalGQL(&buf)
				response.Data = buf.Bytes()
				if atomic.LoadInt32(&ec.deferred) > 0 {
					hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
					response.HasNext = &hasNext
				}

				return &response
			}
		{{ end }}

		{{- if .MutationRoot }} case ast.Mutation:
			return func(ctx context.Context) *graphql.Response {
				if !first { return nil }
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				{{ if .Directives.LocationDirectives "MUTATION" -}}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					data := _mutationMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
						return _{{.MutationRoot.Name}}(ctx, ec, opCtx.Operation.SelectionSet), nil
					{{- else -}}
					data := ec._mutationMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
						return ec._{{.MutationRoot.Name}}(ctx, opCtx.Operation.SelectionSet), nil
					{{- end }}
					})
				{{- else -}}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					data := _{{.MutationRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
					{{- else -}}
					data := ec._{{.MutationRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
					{{- end }}
				{{- end }}
				var buf bytes.Buffer
				data.MarshalGQL(&buf)

				return &graphql.Response{
					Data:       buf.Bytes(),
				}
			}
		{{ end }}

		{{- if .SubscriptionRoot }} case ast.Subscription:
			{{ if .Directives.LocationDirectives "SUBSCRIPTION" -}}
				{{ if $useFunctionSyntaxForExecutionContext -}}
				next := _subscriptionMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
					return _{{.SubscriptionRoot.Name}}(ctx, ec, opCtx.Operation.SelectionSet),nil
				{{- else -}}
				next := ec._subscriptionMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
					return ec._{{.SubscriptionRoot.Name}}(ctx, opCtx.Operation.SelectionSet),nil
				{{- end }}
				})
			{{- else -}}
				{{ if $useFunctionSyntaxForExecutionContext -}}
				next := _{{.SubscriptionRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
				{{- else -}}
				next := ec._{{.SubscriptionRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
				{{- end }}
			{{- end }}

			var buf bytes.Buffer
			return func(ctx context.Context) *graphql.Response {
				buf.Reset()
				data := next(ctx)

				if data == nil {
					return nil
				}
				data.MarshalGQL(&buf)

				return &graphql.Response{
					Data:       buf.Bytes(),
				}
			}
		{{ end }}
		default:
			return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
		}
	}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

{{- if .HasBatchResolverFields }}
type batchContextKey struct{}

type batchParentState struct {
	groups map[string]*batchParentGroup
}

	type batchParentGroup struct {
		parents any
		fields  sync.Map
	}

	type batchFieldResult struct {
		once       sync.Once
		done       chan struct{}
		results    any
		invalidErr error
	}

	type BatchResult[T any] struct {
		Value T
		Err   error
	}

func (ec *executionContext) withBatchParents(ctx context.Context, typeName string, parents any) context.Context {

		prev, _ := ctx.Value(batchContextKey{}).(*batchParentState)
		var groups map[string]*batchParentGroup
		if prev != nil {
			groups = make(map[string]*batchParentGroup, len(prev.groups)+1)
			for k, v := range prev.groups {
				groups[k] = v
			}
		} else {
			groups = make(map[string]*batchParentGroup, 1)
		}
		groups[typeName] = &batchParentGroup{parents: parents}

		return context.WithValue(ctx, batchContextKey{}, &batchParentState{groups: groups})
	}

	func (ec *executionContext) getBatchParentGroup(ctx context.Context, typeName string) *batchParentGroup {
		state, _ := ctx.Value(batchContextKey{}).(*batchParentState)
		if state == nil {
			return nil
		}
		return state.groups[typeName]
	}

	func (g *batchParentGroup) getFieldResult(key string, resolve func() (any, error)) *batchFieldResult {
		if g == nil {
			return nil
		}
		res, _ := g.fields.LoadOrStore(key, &batchFieldResult{done: make(chan struct{})})
		result := res.(*batchFieldResult)
		result.once.Do(func() {
			defer close(result.done)
			result.results, result.invalidErr = resolve()
		})
		<-result.done
		return result
	}

	func (ec *executionContext) batchParentIndex(ctx context.Context) (ast.PathIndex, bool) {
		path := graphql.GetPath(ctx)
		if len(path) < 2 {
			return 0, false
		}
		if idx, ok := path[len(path)-2].(ast.PathIndex); ok {
			return idx, true
		}
		return 0, false
	}

	func (ec *executionContext) batchPathWithIndex(ctx context.Context, index int) ast.Path {
		path := graphql.GetPath(ctx)
		if len(path) < 2 {
			return path
		}
		if _, ok := path[len(path)-2].(ast.PathIndex); !ok {
			return path
		}
		copied := make(ast.Path, len(path))
		copy(copied, path)
		copied[len(path)-2] = ast.PathIndex(index)
		return copied
	}

	func (ec *executionContext) addBatchError(ctx context.Context, index int, err error) {
		if err == nil {
			return
		}
		path := ec.batchPathWithIndex(ctx, index)
		if list, ok := err.(gqlerror.List); ok {
			for _, item := range list {
				if item == nil {
					continue
				}
				if item.Path == nil {
					cloned := *item
					cloned.Path = path
					graphql.AddError(ctx, &cloned)
					continue
				}
				graphql.AddError(ctx, item)
			}
			return
		}
		var gqlErr *gqlerror.Error
		if errors.As(err, &gqlErr) {
			if gqlErr.Path == nil {
				cloned := *gqlErr
				cloned.Path = path
				graphql.AddError(ctx, &cloned)
				return
			}
			graphql.AddError(ctx, gqlErr)
			return
	}
	graphql.AddError(ctx, gqlerror.WrapPath(path, err))
}
{{- end }}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
		atomic.AddInt32(&ec.pendingDeferred, 1)
		go func () {
			ctx := graphql.WithFreshResponseContext(dg.Context)
			dg.FieldSet.Dispatch(ctx)
			ds := graphql.DeferredResult{
				Path:   dg.Path,
				Label:  dg.Label,
				Result: dg.FieldSet,
				Errors: graphql.GetErrors(ctx),
			}
			// null fields should bubble up
			if dg.FieldSet.Invalids > 0 {
				ds.Result = graphql.Null
			}
			ec.deferredResults <- ds
		}()
	}

	func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
		if ec.DisableIntrospection {
			return nil, errors.New("introspection disabled")
		}
		return introspection.WrapSchema(ec.Schema()), nil
	}

	func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
		if ec.DisableIntrospection {
			return nil, errors.New("introspection disabled")
		}
		return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
	}

	{{if .HasEmbeddableSources }}
	//go:embed{{- range $source := .AugmentedSources }}{{if $source.Embeddable}} {{$source.RelativePath|quote}}{{end}}{{- end }}
	var sourcesFS embed.FS

	func sourceData(filename string) string {
		data, err := sourcesFS.ReadFile(filename)
		if err != nil {
			panic(fmt.Sprintf("codegen problem: %s not available", filename))
		}
		return string(data)
	}
	{{- end }}

	var sources = []*ast.Source{
	{{- range $source := .AugmentedSources }}
		{Name: {{$source.RelativePath|quote}}, Input: {{if (not $source.Embeddable)}}{{$source.Source|rawQuote}}{{else}}sourceData({{$source.RelativePath|quote}}){{end}}, BuiltIn: {{$source.BuiltIn}}},
	{{- end }}
	}
	var parsedSchema = gqlparser.MustLoadSchema(sources...)
{{ end }}
