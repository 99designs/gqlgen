{{/* Context object: codegen.splitRootTemplateData */}}
{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "sync/atomic" }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}
{{ reserveImport "embed"  }}

{{ reserveImport "github.com/vektah/gqlparser/v2" "gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/v2/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/executor/shardruntime" }}
{{ reserveImport "golang.org/x/sync/semaphore" }}

{{ $useFunctionSyntaxForExecutionContext := .Config.UseFunctionSyntaxForExecutionContext }}

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema: cfg.Schema,
		resolvers: cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema    *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
{{- range $object := .Objects -}}
	{{ if $object.HasResolvers -}}
		{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
	{{ end }}
{{- end }}
{{- range $object := .Inputs -}}
	{{ if $object.HasResolvers -}}
		{{ucFirst $object.Name}}() {{ucFirst $object.Name}}Resolver
	{{ end }}
{{- end }}
}

type DirectiveRoot struct {
{{ range $directive := .UserDirectives }}
	{{- $directive.Declaration }}
{{ end }}
}

type ComplexityRoot struct {
{{- if not .Config.OmitComplexity }}
{{ range $object := .Objects }}
	{{ if not $object.IsReserved -}}
		{{ ucFirst $object.Name }} struct {
		{{ range $_, $fields := $object.UniqueFields }}
			{{- $field := index $fields 0 -}}
			{{ if not $field.IsReserved -}}
				{{ $field.GoFieldName }} {{ $field.ComplexitySignature }}
			{{ end }}
		{{- end }}
		}
	{{- end }}
{{ end }}
{{- end }}
}

{{ range $object := .Objects -}}
	{{ if $object.HasResolvers }}
		type {{ucFirst $object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $object := .Inputs -}}
	{{ if $object.HasResolvers }}
		type {{$object.Name}}Resolver interface {
		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
				{{- $field.GoFieldName}}{{ $field.ShortResolverDeclaration }}
			{{- end }}
		{{ end }}
		}
	{{- end }}
{{- end }}

{{ range $directive := .BuiltInDirectives }}
	var (
		{{- $directive.FunctionImpl }}
	)
{{ end }}

type executableSchema struct {
	schema    *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
			return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	{{- if not .Config.OmitComplexity }}
	handler, ok := shardruntime.LookupComplexity({{ $.Scope | quote }}, typeName, field)
	if ok {
		return handler(ctx, &ec, childComplexity, rawArgs)
	}
	{{- end }}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		{{- range $input := .Inputs }}
			{{- if not $input.HasUnmarshal }}
				{{- if $useFunctionSyntaxForExecutionContext }}
		func(ctx context.Context, obj any) ({{ if $input.PointersInUnmarshalInput }}*{{ end }}{{ $input.Type | ref }}, error) {
			return unmarshalInput{{ $input.Name }}(ctx, &ec, obj)
		},
				{{- else }}
		ec.unmarshalInput{{ $input.Name }},
				{{- end }}
			{{- end }}
		{{- end }}
	)
	first := true

	switch opCtx.Operation.Operation {
	{{- if .QueryRoot }} case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				{{ if .Directives.LocationDirectives "QUERY" -}}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					data = _queryMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
						return _{{.QueryRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet), nil
					{{- else -}}
					data = ec._queryMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
						return ec._{{.QueryRoot.Name}}(ctx, opCtx.Operation.SelectionSet), nil
					{{- end }}
					})
				{{- else -}}
					{{ if $useFunctionSyntaxForExecutionContext -}}
					data = _{{.QueryRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
					{{- else -}}
					data = ec._{{.QueryRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
					{{- end }}
				{{- end }}
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	{{ end }}

	{{- if .MutationRoot }} case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first { return nil }
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			{{ if .Directives.LocationDirectives "MUTATION" -}}
				{{ if $useFunctionSyntaxForExecutionContext -}}
				data := _mutationMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
					return _{{.MutationRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet), nil
				{{- else -}}
				data := ec._mutationMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
					return ec._{{.MutationRoot.Name}}(ctx, opCtx.Operation.SelectionSet), nil
				{{- end }}
				})
			{{- else -}}
				{{ if $useFunctionSyntaxForExecutionContext -}}
				data := _{{.MutationRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
				{{- else -}}
				data := ec._{{.MutationRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
				{{- end }}
			{{- end }}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data:       buf.Bytes(),
			}
		}
	{{ end }}

	{{- if .SubscriptionRoot }} case ast.Subscription:
		{{ if .Directives.LocationDirectives "SUBSCRIPTION" -}}
			{{ if $useFunctionSyntaxForExecutionContext -}}
			next := _subscriptionMiddleware(ctx, &ec, opCtx.Operation, func(ctx context.Context) (any, error){
				return _{{.SubscriptionRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet),nil
			{{- else -}}
			next := ec._subscriptionMiddleware(ctx, opCtx.Operation, func(ctx context.Context) (any, error){
				return ec._{{.SubscriptionRoot.Name}}(ctx, opCtx.Operation.SelectionSet),nil
			{{- end }}
			})
		{{- else -}}
			{{ if $useFunctionSyntaxForExecutionContext -}}
			next := _{{.SubscriptionRoot.Name}}(ctx, &ec, opCtx.Operation.SelectionSet)
			{{- else -}}
			next := ec._{{.SubscriptionRoot.Name}}(ctx, opCtx.Operation.SelectionSet)
			{{- end }}
		{{- end }}

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data:       buf.Bytes(),
			}
		}
	{{ end }}
	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func () {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

func (ec *executionContext) GetOperationContext() *graphql.OperationContext {
	return ec.OperationContext
}

func (ec *executionContext) ProcessDeferredGroup(dg graphql.DeferredGroup) {
	ec.processDeferredGroup(dg)
}

func (ec *executionContext) AddDeferred(delta int32) {
	atomic.AddInt32(&ec.deferred, delta)
}

func (ec *executionContext) ResolveField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, obj any) graphql.Marshaler {
	handler, ok := shardruntime.LookupField({{ $.Scope | quote }}, objectName, fieldName)
	if !ok {
		panic(fmt.Sprintf("unknown field %s.%s", objectName, fieldName))
	}

	return handler(ctx, ec, field, obj)
}

func (ec *executionContext) ResolveStreamField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, _ any) func(ctx context.Context) graphql.Marshaler {
	handler, ok := shardruntime.LookupStreamField({{ $.Scope | quote }}, objectName, fieldName)
	if !ok {
		panic(fmt.Sprintf("unknown stream field %s.%s", objectName, fieldName))
	}

	return handler(ctx, ec, field, nil)
}

func (ec *executionContext) ResolveExecutableField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, obj any) graphql.Marshaler {
	handler, ok := splitExecutableFieldResolvers[objectName+"."+fieldName]
	if !ok {
		panic(fmt.Sprintf("unknown executable field %s.%s", objectName, fieldName))
	}

	return handler(ctx, ec, field, obj)
}

func (ec *executionContext) ResolveExecutableStreamField(ctx context.Context, objectName, fieldName string, field graphql.CollectedField, obj any) func(context.Context) graphql.Marshaler {
	handler, ok := splitExecutableStreamFieldResolvers[objectName+"."+fieldName]
	if !ok {
		panic(fmt.Sprintf("unknown executable stream field %s.%s", objectName, fieldName))
	}

	return handler(ctx, ec, field, obj)
}

func (ec *executionContext) MarshalCodec(ctx context.Context, funcName string, sel ast.SelectionSet, value any) graphql.Marshaler {
	handler, ok := splitCodecMarshalResolvers[funcName]
	if !ok {
		panic(fmt.Errorf("unknown codec marshal function %s", funcName))
	}

	return handler(ctx, ec, sel, value)
}

func (ec *executionContext) UnmarshalCodec(ctx context.Context, funcName string, value any) (any, error) {
	handler, ok := splitCodecUnmarshalResolvers[funcName]
	if !ok {
		return nil, fmt.Errorf("unknown codec unmarshal function %s", funcName)
	}

	return handler(ctx, ec, value)
}

func (ec *executionContext) ParseFieldArgs(ctx context.Context, argsKey string, rawArgs map[string]any) (map[string]any, error) {
	handler, ok := splitArgsParsers[argsKey]
	if !ok {
		return rawArgs, nil
	}

	return handler(ctx, ec, rawArgs)
}

func (ec *executionContext) ResolveExecutableComplexity(ctx context.Context, objectName, fieldName string, childComplexity int, rawArgs map[string]any) (int, bool) {
	handler, ok := splitExecutableComplexityResolvers[objectName+"."+fieldName]
	if !ok {
		panic(fmt.Sprintf("unknown executable complexity %s.%s", objectName, fieldName))
	}

	return handler(ctx, ec, childComplexity, rawArgs)
}

type splitFieldResolver func(context.Context, *executionContext, graphql.CollectedField, any) graphql.Marshaler

var splitExecutableFieldResolvers = map[string]splitFieldResolver{
{{- range $object := .Objects }}
{{- range $field := $object.Fields }}
	{{ printf "%s.%s" $object.Name $field.Name | quote }}: func(ctx context.Context, ec *executionContext, field graphql.CollectedField, obj any) graphql.Marshaler {
		{{- if $object.Root }}
		{{- if $useFunctionSyntaxForExecutionContext }}
		return _{{ $object.Name }}_{{ $field.Name }}(ctx, ec, field)
		{{- else }}
		return ec._{{ $object.Name }}_{{ $field.Name }}(ctx, field)
		{{- end }}
		{{- else }}
		typedObj, ok := obj.({{ $object.Reference | ref }})
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object {{ $object.Name }}", obj))
		}
		{{- if $useFunctionSyntaxForExecutionContext }}
		return _{{ $object.Name }}_{{ $field.Name }}(ctx, ec, field, typedObj)
		{{- else }}
		return ec._{{ $object.Name }}_{{ $field.Name }}(ctx, field, typedObj)
		{{- end }}
		{{- end }}
	},
{{- end }}
{{- end }}
}

type splitStreamFieldResolver func(context.Context, *executionContext, graphql.CollectedField, any) func(context.Context) graphql.Marshaler

var splitExecutableStreamFieldResolvers = map[string]splitStreamFieldResolver{
{{- range $object := .Objects }}
{{- if $object.Stream }}
{{- range $field := $object.Fields }}
	{{ printf "%s.%s" $object.Name $field.Name | quote }}: func(ctx context.Context, ec *executionContext, field graphql.CollectedField, obj any) func(context.Context) graphql.Marshaler {
		{{- if $object.Root }}
		{{- if $useFunctionSyntaxForExecutionContext }}
		return _{{ $object.Name }}_{{ $field.Name }}(ctx, ec, field)
		{{- else }}
		return ec._{{ $object.Name }}_{{ $field.Name }}(ctx, field)
		{{- end }}
		{{- else }}
		typedObj, ok := obj.({{ $object.Reference | ref }})
		if !ok {
			panic(fmt.Errorf("unexpected type %T for object {{ $object.Name }}", obj))
		}
		{{- if $useFunctionSyntaxForExecutionContext }}
		return _{{ $object.Name }}_{{ $field.Name }}(ctx, ec, field, typedObj)
		{{- else }}
		return ec._{{ $object.Name }}_{{ $field.Name }}(ctx, field, typedObj)
		{{- end }}
		{{- end }}
	},
{{- end }}
{{- end }}
{{- end }}
}

type splitCodecMarshalResolver func(context.Context, *executionContext, ast.SelectionSet, any) graphql.Marshaler

var splitCodecMarshalResolvers = map[string]splitCodecMarshalResolver{
{{- range $ref := .ReferencedTypes }}
{{- $marshalFunc := $ref.MarshalFunc }}
{{- if $marshalFunc }}
	{{ $marshalFunc | quote }}: func(ctx context.Context, ec *executionContext, sel ast.SelectionSet, value any) graphql.Marshaler {
		typedValue, ok := value.({{ $ref.GO | ref }})
		if !ok {
			panic(fmt.Errorf("unexpected codec input %T for {{ $marshalFunc }}", value))
		}
		{{- if $useFunctionSyntaxForExecutionContext }}
		return {{ $marshalFunc }}(ctx, ec, sel, typedValue)
		{{- else }}
		return ec.{{ $marshalFunc }}(ctx, sel, typedValue)
		{{- end }}
	},
{{- end }}
{{- end }}
}

type splitCodecUnmarshalResolver func(context.Context, *executionContext, any) (any, error)

var splitCodecUnmarshalResolvers = map[string]splitCodecUnmarshalResolver{
{{- range $ref := .ReferencedTypes }}
{{- $unmarshalFunc := $ref.UnmarshalFunc }}
{{- if $unmarshalFunc }}
	{{ $unmarshalFunc | quote }}: func(ctx context.Context, ec *executionContext, value any) (any, error) {
		{{- if $useFunctionSyntaxForExecutionContext }}
		return {{ $unmarshalFunc }}(ctx, ec, value)
		{{- else }}
		return ec.{{ $unmarshalFunc }}(ctx, value)
		{{- end }}
	},
{{- end }}
{{- end }}
}

type splitArgsParser func(context.Context, *executionContext, map[string]any) (map[string]any, error)

var splitArgsParsers = map[string]splitArgsParser{
{{- range $object := .Objects }}
{{- range $field := $object.Fields }}
{{- if $field.Args }}
	{{ printf "%s.%s" $object.Name $field.Name | quote }}: func(ctx context.Context, ec *executionContext, rawArgs map[string]any) (map[string]any, error) {
		{{- if $useFunctionSyntaxForExecutionContext }}
		return {{ $field.ArgsFunc }}(ctx, ec, rawArgs)
		{{- else }}
		return ec.{{ $field.ArgsFunc }}(ctx, rawArgs)
		{{- end }}
	},
{{- end }}
{{- end }}
{{- end }}
}

type splitComplexityResolver func(context.Context, *executionContext, int, map[string]any) (int, bool)

var splitExecutableComplexityResolvers = map[string]splitComplexityResolver{
{{- if not .Config.OmitComplexity }}
{{- range $object := .Objects }}
{{- range $field := $object.Fields }}
	{{ printf "%s.%s" $object.Name $field.Name | quote }}: func(ctx context.Context, ec *executionContext, childComplexity int, rawArgs map[string]any) (int, bool) {
		{{- if and (not $object.IsReserved) (not $field.IsReserved) }}
		if ec.complexity.{{ucFirst $object.Name }}.{{$field.GoFieldName}} == nil {
			return 0, false
		}
		{{ if $field.Args }}
			{{ if $useFunctionSyntaxForExecutionContext }}
		args, err := {{ $field.ArgsFunc }}(ctx, ec, rawArgs)
			{{ else }}
		args, err := ec.{{ $field.ArgsFunc }}(ctx, rawArgs)
			{{ end }}
		if err != nil {
			return 0, false
		}
		{{ end }}
		return ec.complexity.{{ucFirst $object.Name}}.{{$field.GoFieldName}}(childComplexity{{if $field.Args}}, {{$field.ComplexityArgs}} {{ end }}), true
		{{- else }}
		return 0, false
		{{- end }}
	},
{{- end }}
{{- end }}
{{- end }}
}

{{- range $object := .Objects }}
	{{- if $object.Stream }}
		{{ if $useFunctionSyntaxForExecutionContext -}}
func _{{$object.Name}}(ctx context.Context, ec *executionContext, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
		{{- else -}}
func (ec *executionContext) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
		{{- end }}
	handler, ok := shardruntime.LookupStreamObject({{ $.Scope | quote }}, {{$object.Name | quote}})
	if !ok {
		panic(fmt.Sprintf("missing stream object shard handler for %s", {{$object.Name | quote}}))
	}
		{{ if $useFunctionSyntaxForExecutionContext -}}
	return handler(ctx, ec, sel)
		{{- else -}}
	return handler(ctx, ec, sel)
		{{- end }}
}
	{{- else }}
		{{ if $useFunctionSyntaxForExecutionContext -}}
func _{{$object.Name}}(ctx context.Context, ec *executionContext, sel ast.SelectionSet{{ if not $object.Root }},obj {{$object.Reference | ref }}{{ end }}) graphql.Marshaler {
		{{- else -}}
func (ec *executionContext) _{{$object.Name}}(ctx context.Context, sel ast.SelectionSet{{ if not $object.Root }},obj {{$object.Reference | ref }}{{ end }}) graphql.Marshaler {
		{{- end }}
	handler, ok := shardruntime.LookupObject({{ $.Scope | quote }}, {{$object.Name | quote}})
	if !ok {
		panic(fmt.Sprintf("missing object shard handler for %s", {{$object.Name | quote}}))
	}
		{{- if $object.Root }}
		{{ if $useFunctionSyntaxForExecutionContext -}}
	return handler(ctx, ec, sel, nil)
		{{- else -}}
	return handler(ctx, ec, sel, nil)
		{{- end }}
		{{- else }}
		{{ if $useFunctionSyntaxForExecutionContext -}}
	return handler(ctx, ec, sel, obj)
		{{- else -}}
	return handler(ctx, ec, sel, obj)
		{{- end }}
		{{- end }}
}
	{{- end }}
{{- end }}

{{if .HasEmbeddableSources }}
//go:embed{{- range $source := .AugmentedSources }}{{if $source.Embeddable}} {{$source.RelativePath|quote}}{{end}}{{- end }}
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}
{{- end }}

var sources = []*ast.Source{
{{- range $source := .AugmentedSources }}
	{Name: {{$source.RelativePath|quote}}, Input: {{if (not $source.Embeddable)}}{{$source.Source|rawQuote}}{{else}}sourceData({{$source.RelativePath|quote}}){{end}}, BuiltIn: {{$source.BuiltIn}}},
{{- end }}
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
