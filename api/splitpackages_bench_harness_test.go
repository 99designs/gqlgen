package api

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestSplitPackagesBenchHarnessSmoke(t *testing.T) {
	wd, err := os.Getwd()
	require.NoError(t, err)

	workDir := filepath.Join(wd, "testdata", "splitpackages")
	t.Cleanup(func() {
		cleanup(workDir)
	})

	payload, err := RunSplitPackagesBenchHarness(workDir)
	require.NoError(t, err)

	summary, err := ParseSplitPackagesBenchSummary(payload)
	require.NoError(t, err)
	require.Equal(t, splitPackagesBenchSummaryContractVersion, summary.ContractVersion)
	require.Equal(t, "split-packages", summary.Layout)
	require.Equal(t, "splitpackages", summary.Fixture)
	require.Positive(t, summary.GeneratedFileCount)
	require.Positive(t, summary.GeneratedBytes)
	require.GreaterOrEqual(t, summary.DurationMillis, int64(0))
}

type splitBenchThreshold struct {
	maxDurationMillis int64
	minGeneratedFiles int
	minGeneratedBytes int64
}

func evaluateSplitBenchThreshold(summary SplitPackagesBenchSummary, threshold splitBenchThreshold) error {
	if summary.DurationMillis > threshold.maxDurationMillis {
		return fmt.Errorf("duration_ms %d exceeds max %d", summary.DurationMillis, threshold.maxDurationMillis)
	}

	if summary.GeneratedFileCount < threshold.minGeneratedFiles {
		return fmt.Errorf("generated_file_count %d below min %d", summary.GeneratedFileCount, threshold.minGeneratedFiles)
	}

	if summary.GeneratedBytes < threshold.minGeneratedBytes {
		return fmt.Errorf("generated_bytes %d below min %d", summary.GeneratedBytes, threshold.minGeneratedBytes)
	}

	return nil
}

func TestSplitBenchThresholdEvaluator(t *testing.T) {
	baseSummary := SplitPackagesBenchSummary{
		ContractVersion:    splitPackagesBenchSummaryContractVersion,
		Layout:             "split-packages",
		Fixture:            "splitpackages",
		GeneratedFileCount: 14,
		GeneratedBytes:     51200,
		DurationMillis:     320,
	}

	tests := []struct {
		name      string
		summary   SplitPackagesBenchSummary
		threshold splitBenchThreshold
		wantErr   string
	}{
		{
			name:    "passes when summary meets all thresholds",
			summary: baseSummary,
			threshold: splitBenchThreshold{
				maxDurationMillis: 320,
				minGeneratedFiles: 14,
				minGeneratedBytes: 51200,
			},
		},
		{
			name:    "fails when duration exceeds max",
			summary: baseSummary,
			threshold: splitBenchThreshold{
				maxDurationMillis: 319,
				minGeneratedFiles: 14,
				minGeneratedBytes: 51200,
			},
			wantErr: "duration_ms 320 exceeds max 319",
		},
		{
			name: "fails when generated files below min",
			summary: SplitPackagesBenchSummary{
				ContractVersion:    splitPackagesBenchSummaryContractVersion,
				Layout:             "split-packages",
				Fixture:            "splitpackages",
				GeneratedFileCount: 10,
				GeneratedBytes:     51200,
				DurationMillis:     320,
			},
			threshold: splitBenchThreshold{
				maxDurationMillis: 400,
				minGeneratedFiles: 11,
				minGeneratedBytes: 51200,
			},
			wantErr: "generated_file_count 10 below min 11",
		},
		{
			name: "fails when generated bytes below min",
			summary: SplitPackagesBenchSummary{
				ContractVersion:    splitPackagesBenchSummaryContractVersion,
				Layout:             "split-packages",
				Fixture:            "splitpackages",
				GeneratedFileCount: 14,
				GeneratedBytes:     4096,
				DurationMillis:     320,
			},
			threshold: splitBenchThreshold{
				maxDurationMillis: 400,
				minGeneratedFiles: 14,
				minGeneratedBytes: 5000,
			},
			wantErr: "generated_bytes 4096 below min 5000",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			payload, err := json.Marshal(tt.summary)
			require.NoError(t, err)

			parsed, err := ParseSplitPackagesBenchSummary(payload)
			require.NoError(t, err)

			err = evaluateSplitBenchThreshold(parsed, tt.threshold)
			if tt.wantErr == "" {
				require.NoError(t, err)
				return
			}

			require.EqualError(t, err, tt.wantErr)
		})
	}
}
