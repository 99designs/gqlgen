package batchresolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.87

import (
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*User, error) {
	if r.users == nil {
		return nil, errors.New("users not set")
	}
	return r.users, nil
}

// NullableBatch is the batch resolver for the nullableBatch field.
func (r *userResolver) NullableBatch(ctx context.Context, objs []*User) ([]*Profile, error) {
	if r.batchResultsWrongLen {
		results := make([]*Profile, r.batchResultsLen)
		errs := make([]error, len(objs))
		return results, graphql.BatchErrorList(errs)
	}
	if r.batchErrsWrongLen {
		results := make([]*Profile, len(objs))
		errs := make([]error, r.batchErrsLen)
		return results, graphql.BatchErrorList(errs)
	}
	if r.batchErrListIdxs != nil {
		results := make([]*Profile, len(objs))
		errs := make([]error, len(objs))
		for i, obj := range objs {
			idx := r.userIndex(obj)
			if idx >= 0 && idx < len(r.profiles) {
				results[i] = r.profiles[idx]
			}
			if _, ok := r.batchErrListIdxs[idx]; ok {
				errs[i] = gqlerror.List{
					gqlerror.Errorf("batch list error 1 at index %d", idx),
					gqlerror.Errorf("batch list error 2 at index %d", idx),
				}
			}
		}
		return results, graphql.BatchErrorList(errs)
	}
	if r.profileWrongLen {
		if len(objs) == 0 {
			return nil, nil
		}
		idx := r.userIndex(objs[0])
		value, _ := resolveProfile(r.Resolver, idx)
		return []*Profile{value}, nil
	}

	results := make([]*Profile, len(objs))
	errs := make([]error, len(objs))
	hasErr := false
	for i, obj := range objs {
		idx := r.userIndex(obj)
		value, err := resolveProfile(r.Resolver, idx)
		results[i] = value
		errs[i] = err
		if err != nil {
			hasErr = true
		}
	}
	if hasErr {
		return results, graphql.BatchErrorList(errs)
	}
	return results, nil
}

// NullableNonBatch is the resolver for the nullableNonBatch field.
func (r *userResolver) NullableNonBatch(ctx context.Context, obj *User) (*Profile, error) {
	idx := r.userIndex(obj)
	return resolveProfile(r.Resolver, idx)
}

// NullableBatchWithArg is the batch resolver for the nullableBatchWithArg field.
func (r *userResolver) NullableBatchWithArg(ctx context.Context, objs []*User, offset int) ([]*Profile, error) {
	if r.profileWrongLen {
		if len(objs) == 0 {
			return nil, nil
		}
		idx := r.userIndex(objs[0]) + offset
		value, _ := resolveProfile(r.Resolver, idx)
		return []*Profile{value}, nil
	}

	results := make([]*Profile, len(objs))
	errs := make([]error, len(objs))
	hasErr := false
	for i, obj := range objs {
		idx := r.userIndex(obj) + offset
		value, err := resolveProfile(r.Resolver, idx)
		results[i] = value
		errs[i] = err
		if err != nil {
			hasErr = true
		}
	}
	if hasErr {
		return results, graphql.BatchErrorList(errs)
	}
	return results, nil
}

// NullableNonBatchWithArg is the resolver for the nullableNonBatchWithArg field.
func (r *userResolver) NullableNonBatchWithArg(ctx context.Context, obj *User, offset int) (*Profile, error) {
	idx := r.userIndex(obj) + offset
	return resolveProfile(r.Resolver, idx)
}

// NonNullableBatch is the batch resolver for the nonNullableBatch field.
func (r *userResolver) NonNullableBatch(ctx context.Context, objs []*User) ([]*Profile, error) {
	if r.profileWrongLen {
		if len(objs) == 0 {
			return nil, nil
		}
		idx := r.userIndex(objs[0])
		value, _ := resolveProfile(r.Resolver, idx)
		return []*Profile{value}, nil
	}

	results := make([]*Profile, len(objs))
	errs := make([]error, len(objs))
	hasErr := false
	for i, obj := range objs {
		idx := r.userIndex(obj)
		value, err := resolveProfile(r.Resolver, idx)
		results[i] = value
		errs[i] = err
		if err != nil {
			hasErr = true
		}
	}
	if hasErr {
		return results, graphql.BatchErrorList(errs)
	}
	return results, nil
}

// NonNullableNonBatch is the resolver for the nonNullableNonBatch field.
func (r *userResolver) NonNullableNonBatch(ctx context.Context, obj *User) (*Profile, error) {
	idx := r.userIndex(obj)
	return resolveProfile(r.Resolver, idx)
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
