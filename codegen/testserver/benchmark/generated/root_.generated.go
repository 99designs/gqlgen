// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/codegen/testserver/benchmark/generated/models"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{SchemaData: cfg.Schema, Resolvers: cfg.Resolvers, Directives: cfg.Directives, ComplexityRoot: cfg.Complexity}
}

type Config = graphql.Config[ResolverRoot, DirectiveRoot, ComplexityRoot]

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Users func(childComplexity int, query *string, first *int, last *int, before *string, after *string, orderBy models.UserOrderBy) int
	}

	User struct {
		Email     func(childComplexity int) int
		FirstName func(childComplexity int) int
		LastName  func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema graphql.ExecutableSchemaState[ResolverRoot, DirectiveRoot, ComplexityRoot]

func (e *executableSchema) Schema() *ast.Schema {
	if e.SchemaData != nil {
		return e.SchemaData
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "PageInfo.endCursor":
		if e.ComplexityRoot.PageInfo.EndCursor == nil {
			break
		}

		return e.ComplexityRoot.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.ComplexityRoot.PageInfo.HasNextPage == nil {
			break
		}

		return e.ComplexityRoot.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.ComplexityRoot.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.ComplexityRoot.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.ComplexityRoot.PageInfo.StartCursor == nil {
			break
		}

		return e.ComplexityRoot.PageInfo.StartCursor(childComplexity), true

	case "Query.users":
		if e.ComplexityRoot.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.ComplexityRoot.Query.Users(childComplexity, args["query"].(*string), args["first"].(*int), args["last"].(*int), args["before"].(*string), args["after"].(*string), args["orderBy"].(models.UserOrderBy)), true

	case "User.email":
		if e.ComplexityRoot.User.Email == nil {
			break
		}

		return e.ComplexityRoot.User.Email(childComplexity), true

	case "User.firstName":
		if e.ComplexityRoot.User.FirstName == nil {
			break
		}

		return e.ComplexityRoot.User.FirstName(childComplexity), true

	case "User.lastName":
		if e.ComplexityRoot.User.LastName == nil {
			break
		}

		return e.ComplexityRoot.User.LastName(childComplexity), true

	case "UserConnection.edges":
		if e.ComplexityRoot.UserConnection.Edges == nil {
			break
		}

		return e.ComplexityRoot.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.ComplexityRoot.UserConnection.PageInfo == nil {
			break
		}

		return e.ComplexityRoot.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.ComplexityRoot.UserConnection.TotalCount == nil {
			break
		}

		return e.ComplexityRoot.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.ComplexityRoot.UserEdge.Cursor == nil {
			break
		}

		return e.ComplexityRoot.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.ComplexityRoot.UserEdge.Node == nil {
			break
		}

		return e.ComplexityRoot.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputUserOrderBy,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphql", Input: `type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String!
    endCursor: String!
}

enum OrderDirection {
    ASCENDING
    DESCENDING
}

enum UserOrderField {
    FIRST_NAME
    LAST_NAME
    EMAIL
}

input UserOrderBy {
    orderByField: UserOrderField!
    orderByDirection: OrderDirection!
}

type User {
    firstName: String!
    lastName: String!
    email: String!
}

type UserEdge {
    cursor: String!
    node: User!
}

type UserConnection {
    edges: [UserEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type Query {
    users(
        query: String
        first: Int
        last: Int
        before: String
        after: String
        orderBy: UserOrderBy! = { orderByField: FIRST_NAME orderByDirection: ASCENDING }
    ): UserConnection
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
